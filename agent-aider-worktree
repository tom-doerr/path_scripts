#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
import time
from pathlib import Path


def run_command(cmd, cwd=None, capture_output=True, check=True):
    """Run a shell command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            cwd=cwd,
            shell=True,
            text=True,
            capture_output=capture_output,
            check=check
        )
        return result
    except subprocess.CalledProcessError as e:
        if capture_output:
            print(f"Command failed: {cmd}")
            print(f"Error: {e.stderr}")
        return e


def get_repo_name(repo_path):
    """Get the repository name from the git remote URL."""
    result = run_command("git remote get-url origin", cwd=repo_path)
    if result.returncode != 0:
        return "unknown_repo"
    
    remote_url = result.stdout.strip()
    # Extract repo name from URL (works for both HTTPS and SSH URLs)
    repo_name = remote_url.split('/')[-1].replace('.git', '')
    return repo_name


def create_worktree(repo_path, task_name):
    """Create a new git worktree for the task."""
    repo_name = get_repo_name(repo_path)
    worktree_base = os.path.expanduser(f"~/worktrees/{repo_name}")
    
    # Create the base directory if it doesn't exist
    os.makedirs(worktree_base, exist_ok=True)
    
    # Create a sanitized directory name from the task
    safe_task_name = "".join(c if c.isalnum() else "_" for c in task_name)
    safe_task_name = safe_task_name[:50]  # Limit length
    
    # Add timestamp to make it unique
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    worktree_path = os.path.join(worktree_base, f"{safe_task_name}_{timestamp}")
    
    # Get the current branch
    result = run_command("git branch --show-current", cwd=repo_path)
    current_branch = result.stdout.strip()
    
    # Create a new branch for the task
    branch_name = f"task/{safe_task_name}_{timestamp}"
    print(f"Creating new branch: {branch_name}")
    run_command(f"git branch {branch_name}", cwd=repo_path)
    
    # Create the worktree
    print(f"Creating worktree at: {worktree_path}")
    run_command(f"git worktree add {worktree_path} {branch_name}", cwd=repo_path)
    
    return worktree_path, branch_name, current_branch


def run_tests(worktree_path):
    """Run pytest and return True if all tests pass."""
    result = run_command("pytest", cwd=worktree_path, check=False)
    return result.returncode == 0


def run_aider(worktree_path, task, model="r1"):
    """Run aider with the given task."""
    print(f"\n=== Running aider with task: {task} ===\n")
    
    # Check for instruction file in dotfiles
    instruction_file = os.path.expanduser("~/dotfiles/instruction.md")
    plex_file = "plex.md"
    context_file = "context.txt"
    
    read_args = []
    if os.path.exists(instruction_file):
        read_args.append(f"--read {instruction_file}")
    
    # Check for plex.md and context.txt in the worktree
    if os.path.exists(os.path.join(worktree_path, plex_file)):
        read_args.append(f"--read {plex_file}")
    
    if os.path.exists(os.path.join(worktree_path, context_file)):
        read_args.append(f"--read {context_file}")
    
    read_args_str = " ".join(read_args)
    
    # Using subprocess.run directly to allow interactive session
    subprocess.run(
        f"aider --architect --model {model} --subtree-only {read_args_str} "
        f"--yes-always --no-show-model-warnings "
        f"--weak-model 'openrouter/google/gemini-2.0-flash-001' "
        f"--message '{task}' **/*.py",
        cwd=worktree_path,
        shell=True,
        text=True
    )


def merge_and_push(worktree_path, main_repo_path, branch_name, main_branch):
    """Merge changes from main, then push if no conflicts."""
    # First pull latest changes from main branch
    print(f"Pulling latest changes from {main_branch}...")
    run_command(f"git checkout {main_branch}", cwd=main_repo_path)
    run_command("git pull", cwd=main_repo_path)
    
    # Update the worktree
    print("Updating worktree with latest changes...")
    run_command(f"git pull origin {main_branch}", cwd=worktree_path, check=False)
    
    # Check for merge conflicts
    status = run_command("git status", cwd=worktree_path)
    if "You have unmerged paths" in status.stdout or "fix conflicts" in status.stdout:
        print("Merge conflicts detected. Please resolve them with aider.")
        return False
    
    # Commit any changes from the merge
    run_command("git commit -am 'Merge from main'", cwd=worktree_path, check=False)
    
    # Push changes to the branch
    print(f"Pushing changes to branch {branch_name}...")
    run_command(f"git push -u origin {branch_name}", cwd=worktree_path)
    
    # Merge back to main if requested
    print(f"Merging {branch_name} into {main_branch}...")
    result = run_command(f"git checkout {main_branch} && git merge {branch_name} && git push", 
                        cwd=main_repo_path, check=False)
    
    if result.returncode != 0:
        print("Failed to merge to main. Please resolve conflicts manually.")
        return False
    
    print(f"Successfully merged {branch_name} into {main_branch} and pushed!")
    return True


def main():
    parser = argparse.ArgumentParser(
        description="Create a git worktree and run aider until tests pass, then merge back to main.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s "Add user authentication feature"
  %(prog)s -p /path/to/repo "Fix bug in login form"
  %(prog)s --model claude-3-opus "Implement new feature"
        """
    )
    
    parser.add_argument("task", help="The task description to pass to aider")
    parser.add_argument("-p", "--path", default=".", 
                        help="Path to the main git repository (default: current directory)")
    parser.add_argument("--no-push", action="store_true", 
                        help="Don't push changes back to main repository")
    parser.add_argument("--model", default="r1",
                        help="Model to use with aider (default: r1)")
    
    args = parser.parse_args()
    
    # Get absolute path to the main repository
    main_repo_path = os.path.abspath(args.path)
    
    # Check if the path is a git repository
    if not os.path.exists(os.path.join(main_repo_path, ".git")):
        print(f"Error: {main_repo_path} is not a git repository")
        sys.exit(1)
    
    # Create worktree
    worktree_path, branch_name, main_branch = create_worktree(main_repo_path, args.task)
    
    # Main loop
    while True:
        # Run aider
        run_aider(worktree_path, args.task, args.model)
        
        # Run tests
        print("\n=== Running tests ===\n")
        tests_pass = run_tests(worktree_path)
        
        if tests_pass:
            print("\n‚úÖ All tests passed!")
            
            # Commit any remaining changes
            run_command("git add -A && git commit -m 'Final changes' || true", cwd=worktree_path)
            
            if not args.no_push:
                # Try to merge and push
                merge_success = merge_and_push(worktree_path, main_repo_path, branch_name, main_branch)
                
                if merge_success:
                    print("\nüéâ Task completed successfully!")
                    break
                else:
                    print("\nMerge conflicts detected. Running aider again to resolve conflicts...")
                    continue
            else:
                print("\nüéâ Task completed successfully! (No push requested)")
                break
        else:
            print("\n‚ùå Tests failed. Running aider again...")


if __name__ == "__main__":
    main()
