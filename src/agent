#!/usr/bin/env python3
# Make sure this file is executable with: chmod +x agent

import os
import sys
import json
import subprocess
import xml.etree.ElementTree as ET
import xml.dom.minidom as minidom
from typing import Dict, List, Optional, Any, Tuple
import litellm
from rich.console import Console

class Agent:
    def __init__(self, model_name: str = "openrouter/deepseek/deepseek-r1"):
        self.console = Console()
        self.model_name = model_name
        self.plan_tree = None
        self.repository_info = {}
        self.config = {
            "stream_reasoning": True,
            "verbose": True
        }
        
        # Use native API if model is specified as r1
        if model_name == "r1":
            self.model_name = "deepseek/deepseek-reasoner"
        
    def initialize(self, repo_path: str = ".") -> None:
        """Initialize the agent with repository information"""
        self.repository_info = self.analyze_repository(repo_path)
        print(f"Agent initialized for repository: {repo_path}")
        
    def analyze_repository(self, repo_path: str) -> Dict[str, Any]:
        """Analyze the repository structure and return information"""
        repo_info = {
            "files": [],
            "directories": [],
            "git_info": {}
        }
        
        # Get list of files (excluding .git directory)
        try:
            result = subprocess.run(
                ["git", "ls-files"], 
                cwd=repo_path,
                capture_output=True, 
                text=True, 
                check=True
            )
            repo_info["files"] = result.stdout.strip().split("\n")
        except subprocess.CalledProcessError:
            # Fallback if git command fails
            for root, dirs, files in os.walk(repo_path):
                if ".git" in root:
                    continue
                for file in files:
                    full_path = os.path.join(root, file)
                    rel_path = os.path.relpath(full_path, repo_path)
                    repo_info["files"].append(rel_path)
                for dir in dirs:
                    if dir != ".git":
                        full_path = os.path.join(root, dir)
                        rel_path = os.path.relpath(full_path, repo_path)
                        repo_info["directories"].append(rel_path)
        
        # Get git info if available
        try:
            result = subprocess.run(
                ["git", "branch", "--show-current"], 
                cwd=repo_path,
                capture_output=True, 
                text=True, 
                check=True
            )
            repo_info["git_info"]["current_branch"] = result.stdout.strip()
        except subprocess.CalledProcessError:
            repo_info["git_info"]["current_branch"] = "unknown"
            
        return repo_info
    
    def generate_plan(self, spec: str) -> str:
        """Generate a plan tree based on the specification"""
        prompt = f"""
        Based on the following specification, create a hierarchical plan as an XML tree.
        
        SPECIFICATION:
        {spec}
        
        REPOSITORY INFORMATION:
        {json.dumps(self.repository_info, indent=2)}
        
        Create a detailed plan with tasks and subtasks. The plan should be in XML format with the following structure:
        
        <plan>
          <task id="root" description="Main project goal">
            <task id="task1" description="Component 1">
              <task id="task1.1" description="Subtask 1.1" status="pending" complexity="medium" depends_on="" progress="0" />
              <task id="task1.2" description="Subtask 1.2" status="pending" complexity="low" depends_on="task1.1" progress="0" />
            </task>
            <task id="task2" description="Component 2">
              <task id="task2.1" description="Subtask 2.1" status="pending" complexity="high" depends_on="task1.2" progress="0" />
            </task>
          </task>
        </plan>
        
        Each task should have:
        - A unique id
        - A clear description
        - A status (pending, in-progress, completed, failed)
        - A complexity estimate (low, medium, high)
        - Dependencies (depends_on attribute with comma-separated task IDs)
        - Progress indicator (0-100)
        - Subtasks where appropriate
        
        Think step by step about the dependencies between tasks and how to break down the problem effectively.
        """
        
        print("\n=== Prompt Sent to Model ===\n")
        print(prompt)
        print("\n=== End Prompt ===\n")
        response = self.stream_reasoning(prompt)
        
        # Extract XML from the response
        xml_content = self.extract_xml_from_response(response, "plan")
        if xml_content:
            self.plan_tree = xml_content
            return self.format_xml_response({"plan": xml_content})
        else:
            return self.format_xml_response({"error": "Failed to generate plan"})
    
    def extract_xml_from_response(self, response: str, tag_name: str) -> Optional[str]:
        """Extract XML content for a specific tag from the response"""
        try:
            # Look for XML content in the response
            start_tag = f"<{tag_name}"
            end_tag = f"</{tag_name}>"
            
            start_index = response.find(start_tag)
            end_index = response.find(end_tag, start_index) + len(end_tag)
            
            if start_index != -1 and end_index != -1:
                return response[start_index:end_index]
            return None
        except Exception as e:
            print(f"Error extracting XML: {e}")
            return None
    
    def stream_reasoning(self, prompt: str) -> str:
        """Stream the reasoning process from the model and return the final response"""
        messages = [{"role": "user", "content": prompt}]
        
        if not self.config["stream_reasoning"]:
            # Non-streaming mode
            try:
                response = litellm.completion(
                    model=self.model_name,
                    messages=messages,
                    timeout=60  # Add timeout to prevent hanging
                )
                return response.choices[0].message.content
            except Exception as e:
                print(f"Error in non-streaming mode: {e}")
                return f"Error: {str(e)}"
        
        # Streaming mode
        print("\n--- Streaming Reasoning ---\n")
        full_response = ""
        reasoning_output = ""
        
        try:
            # Add timeout to prevent hanging
            response = litellm.completion(
                model=self.model_name,
                messages=messages,
                stream=True,
                timeout=60
            )
            
            for chunk in response:
                # Handle regular content
                if hasattr(chunk.choices[0], 'delta') and hasattr(chunk.choices[0].delta, 'content'):
                    content = chunk.choices[0].delta.content
                    if content:
                        # More thorough cleaning of control characters and special tokens
                        clean_content = content.replace('\r', '').replace('\b', '')
                        # Remove any potential token markers or brackets that might be causing display issues
                        clean_content = clean_content.replace('[', '').replace(']', '')
                        print(clean_content, end='')
                        full_response += clean_content
                
                # Handle reasoning content separately (for deepseek models)
                if hasattr(chunk.choices[0], 'delta') and hasattr(chunk.choices[0].delta, 'reasoning_content'):
                    reasoning = chunk.choices[0].delta.reasoning_content
                    if reasoning:
                        # Clean up control chars and split into tokens
                        clean_reasoning = reasoning.replace('\r', '').replace('\b', '')
                        tokens = clean_reasoning.split(' ')
                        
                        # Print full reasoning content with rich color
                        self.console.print(f"[yellow]{clean_reasoning}[/yellow]", end='', flush=True)
                        reasoning_output += clean_reasoning + ' '
            
            print("\n\n--- End of Reasoning ---\n")
            
            # Save reasoning to a file for reference
            if reasoning_output:
                with open("last_reasoning.txt", "w") as f:
                    f.write(reasoning_output)
                
            return full_response
            
        except KeyboardInterrupt:
            print("\n\nOperation cancelled by user")
            return full_response
        except Exception as e:
            print(f"\nError during streaming: {e}")
            return full_response or f"Error: {str(e)}"
    
    def format_xml_response(self, content_dict: Dict[str, Any]) -> str:
        """Format various content pieces into an XML response"""
        root = ET.Element("agent-response")
        
        for key, value in content_dict.items():
            if value is None:
                continue
                
            if isinstance(value, str) and value.strip().startswith("<") and value.strip().endswith(">"):
                # This is already XML content, parse it and add as a subtree
                try:
                    # Parse the XML string
                    element = ET.fromstring(value)
                    root.append(element)
                except ET.ParseError:
                    # If parsing fails, add as text
                    child = ET.SubElement(root, key)
                    child.text = value
            else:
                # Add as regular element
                child = ET.SubElement(root, key)
                if isinstance(value, dict):
                    child.text = json.dumps(value)
                else:
                    child.text = str(value)
        
        # Convert to string with pretty formatting
        xml_str = ET.tostring(root, encoding='unicode')
        
        # Use a custom function to format XML more cleanly
        return self.pretty_format_xml(xml_str)
    
    def pretty_format_xml(self, xml_string: str) -> str:
        """Format XML string in a cleaner way than minidom"""
        try:
            # Parse the XML
            root = ET.fromstring(xml_string)
            
            # Function to recursively format XML
            def format_elem(elem, level=0):
                indent = "  " * level
                result = []
                
                # Add opening tag with attributes
                attrs = " ".join([f'{k}="{v}"' for k, v in elem.attrib.items()])
                tag_open = f"{indent}<{elem.tag}{' ' + attrs if attrs else ''}>"
                
                # Check if element has children or text
                children = list(elem)
                if children or (elem.text and elem.text.strip()):
                    result.append(tag_open)
                    
                    # Add text if present
                    if elem.text and elem.text.strip():
                        text_lines = elem.text.strip().split('\n')
                        if len(text_lines) > 1:
                            # Multi-line text
                            result.append("")
                            for line in text_lines:
                                result.append(f"{indent}  {line}")
                            result.append("")
                        else:
                            # Single line text
                            result.append(f"{indent}  {elem.text.strip()}")
                    
                    # Add children
                    for child in children:
                        result.extend(format_elem(child, level + 1))
                    
                    # Add closing tag
                    result.append(f"{indent}</{elem.tag}>")
                else:
                    # Empty element
                    result.append(f"{tag_open}</{elem.tag}>")
                
                return result
            
            # Format the XML
            formatted = format_elem(root)
            return "\n".join(formatted)
            
        except ET.ParseError:
            # Fallback to minidom if our custom formatter fails
            try:
                pretty_xml = minidom.parseString(xml_string).toprettyxml(indent="  ")
                lines = [line for line in pretty_xml.split('\n') if line.strip()]
                return '\n'.join(lines)
            except:
                # If all else fails, return the original string
                return xml_string
    
    def update_plan(self, task_id: str, new_status: str, notes: Optional[str] = None, progress: Optional[str] = None) -> str:
        """Update the status of a task in the plan"""
        if not self.plan_tree:
            return self.format_xml_response({"error": "No plan exists"})
        
        try:
            # Parse the plan tree
            root = ET.fromstring(self.plan_tree)
            
            # Find the task with the given ID
            task_found = False
            for task in root.findall(".//task[@id='{}']".format(task_id)):
                task.set("status", new_status)
                if notes:
                    task.set("notes", notes)
                if progress and progress.isdigit() and 0 <= int(progress) <= 100:
                    task.set("progress", progress)
                task_found = True
            
            if not task_found:
                return self.format_xml_response({"error": f"Task {task_id} not found"})
            
            # Update the plan tree
            self.plan_tree = ET.tostring(root, encoding='unicode')
            
            return self.format_xml_response({
                "plan": self.plan_tree,
                "status": f"Updated task {task_id} to {new_status}"
            })
            
        except Exception as e:
            return self.format_xml_response({"error": f"Error updating plan: {str(e)}"})
    
    def display_plan_tree(self) -> str:
        """Display the current plan tree"""
        if not self.plan_tree:
            return self.format_xml_response({"error": "No plan exists"})
        
        return self.format_xml_response({"plan": self.plan_tree})
    
    def apply_plan_updates(self, plan_update_xml: str) -> None:
        """Apply updates to the plan tree based on the plan_update XML"""
        if not self.plan_tree:
            return
        
        try:
            # Parse the plan tree and updates
            plan_root = ET.fromstring(self.plan_tree)
            updates_root = ET.fromstring(plan_update_xml)
            
            # Process add_task elements
            for add_task in updates_root.findall("./add_task"):
                parent_id = add_task.get("parent_id")
                
                # Find the parent task
                parent = plan_root.find(f".//task[@id='{parent_id}']")
                if parent is not None:
                    # Create a new task element
                    new_task = ET.Element("task")
                    
                    # Copy all attributes from add_task to new_task
                    for attr, value in add_task.attrib.items():
                        if attr != "parent_id":  # Skip the parent_id attribute
                            new_task.set(attr, value)
                    
                    # Add the new task to the parent
                    parent.append(new_task)
                    print(f"Added new task {new_task.get('id')}: {new_task.get('description')}")
            
            # Process modify_task elements
            for modify_task in updates_root.findall("./modify_task"):
                task_id = modify_task.get("id")
                
                # Find the task to modify
                task = plan_root.find(f".//task[@id='{task_id}']")
                if task is not None:
                    old_desc = task.get("description", "")
                    # Update attributes
                    for attr, value in modify_task.attrib.items():
                        if attr != "id":  # Skip the id attribute
                            task.set(attr, value)
                    new_desc = task.get("description", "")
                    if old_desc != new_desc:
                        print(f"Modified task {task_id}: {old_desc} -> {new_desc}")
                    else:
                        print(f"Updated attributes for task {task_id}")
            
            # Process remove_task elements
            for remove_task in updates_root.findall("./remove_task"):
                task_id = remove_task.get("id")
                
                # Find the task to remove
                task = plan_root.find(f".//task[@id='{task_id}']")
                if task is not None:
                    desc = task.get("description", "")
                    # ElementTree in Python doesn't have getparent() method
                    # We need to find the parent manually
                    for potential_parent in plan_root.findall(".//task"):
                        for child in potential_parent.findall("./task"):
                            if child.get("id") == task_id:
                                potential_parent.remove(child)
                                print(f"Removed task {task_id}: {desc}")
                                break
            
            # Update the plan tree
            self.plan_tree = ET.tostring(plan_root, encoding='unicode')
            print("Plan has been updated by the agent")
            
        except Exception as e:
            print(f"Error applying plan updates: {e}")
    
    def check_dependencies(self, task_id: str) -> Tuple[bool, List[str]]:
        """Check if all dependencies for a task are completed"""
        if not self.plan_tree:
            return False, ["No plan exists"]
        
        try:
            # Parse the plan tree
            root = ET.fromstring(self.plan_tree)
            
            # Find the task with the given ID
            task_element = root.find(f".//task[@id='{task_id}']")
            if task_element is None:
                return False, [f"Task {task_id} not found"]
            
            # Get dependencies
            depends_on = task_element.get("depends_on", "")
            if not depends_on:
                return True, []  # No dependencies
            
            # Check each dependency
            dependency_ids = [dep.strip() for dep in depends_on.split(",") if dep.strip()]
            incomplete_deps = []
            
            for dep_id in dependency_ids:
                dep_element = root.find(f".//task[@id='{dep_id}']")
                if dep_element is None:
                    incomplete_deps.append(f"Dependency {dep_id} not found")
                    continue
                
                status = dep_element.get("status", "")
                if status != "completed":
                    desc = dep_element.get("description", "")
                    incomplete_deps.append(f"Dependency {dep_id} ({desc}) is not completed (status: {status})")
            
            return len(incomplete_deps) == 0, incomplete_deps
            
        except Exception as e:
            return False, [f"Error checking dependencies: {str(e)}"]
    
    def execute_task(self, task_id: str) -> str:
        """Execute a specific task from the plan"""
        if not self.plan_tree:
            return self.format_xml_response({"error": "No plan exists"})
        
        try:
            # Parse the plan tree
            root = ET.fromstring(self.plan_tree)
            
            # Find the task with the given ID
            task_element = root.find(f".//task[@id='{task_id}']")
            if task_element is None:
                return self.format_xml_response({"error": f"Task {task_id} not found"})
            
            # Get task details
            description = task_element.get("description", "")
            current_status = task_element.get("status", "pending")
            
            # Check if task is already completed
            if current_status == "completed":
                return self.format_xml_response({
                    "warning": f"Task {task_id} is already marked as completed",
                    "task": {
                        "id": task_id,
                        "description": description,
                        "status": current_status
                    }
                })
            
            # Check dependencies
            deps_met, missing_deps = self.check_dependencies(task_id)
            if not deps_met:
                return self.format_xml_response({
                    "error": "Dependencies not met",
                    "task": {
                        "id": task_id,
                        "description": description
                    },
                    "missing_dependencies": missing_deps
                })
            
            # Update task status to in-progress
            task_element.set("status", "in-progress")
            task_element.set("progress", "10")  # Start with 10% progress
            self.plan_tree = ET.tostring(root, encoding='unicode')
            
            print(f"Executing task {task_id}: {description}")
            print(f"Status updated to: in-progress (10%)")
            
            # Generate actions for this task
            prompt = f"""
            I need to execute the following task:
            
            TASK ID: {task_id}
            DESCRIPTION: {description}
            
            REPOSITORY INFORMATION:
            {json.dumps(self.repository_info, indent=2)}
            
            CURRENT PLAN:
            {self.plan_tree}
            
            Generate the necessary actions to complete this task. The actions should be in XML format:
            
            <actions>
              <action type="create_file" path="example.py">
                # Python code here
              </action>
              <action type="modify_file" path="existing.py">
                <change>
                  <original>def old_function():</original>
                  <new>def new_function():</new>
                </change>
              </action>
              <action type="run_command" command="pytest tests/test_example.py" />
            </actions>
            
            You can also suggest modifications to the plan if needed:
            
            <plan_update>
              <add_task parent_id="task1" id="task1.3" description="New subtask" status="pending" complexity="medium" depends_on="" progress="0" />
              <modify_task id="task2" description="Updated description" />
              <remove_task id="task3" />
            </plan_update>
            
            Think step by step about what needs to be done to complete this task.
            """
            
            # Update progress to 30% - planning phase
            task_element.set("progress", "30")
            self.plan_tree = ET.tostring(root, encoding='unicode')
            print(f"Progress updated to: 30% (planning phase)")
            
            response = self.stream_reasoning(prompt)
            
            # Update progress to 50% - actions generated
            task_element.set("progress", "50")
            self.plan_tree = ET.tostring(root, encoding='unicode')
            print(f"Progress updated to: 50% (actions generated)")
            
            # Extract actions XML from the response
            actions_xml = self.extract_xml_from_response(response, "actions")
            plan_update_xml = self.extract_xml_from_response(response, "plan_update")
            
            # Apply plan updates if present
            if plan_update_xml:
                self.apply_plan_updates(plan_update_xml)
            
            if actions_xml:
                # Update progress to 70% - ready for execution
                task_element.set("progress", "70")
                self.plan_tree = ET.tostring(root, encoding='unicode')
                print(f"Progress updated to: 70% (ready for execution)")
                
                return self.format_xml_response({
                    "task": {
                        "id": task_id,
                        "description": description,
                        "progress": "70"
                    },
                    "actions": actions_xml,
                    "plan_update": plan_update_xml if plan_update_xml else None
                })
            else:
                # Update task status to failed
                task_element.set("status", "failed")
                task_element.set("notes", "Failed to generate actions")
                task_element.set("progress", "0")
                self.plan_tree = ET.tostring(root, encoding='unicode')
                print(f"Task {task_id} failed: Could not generate actions")
                
                return self.format_xml_response({
                    "error": "Failed to generate actions for task",
                    "task": {
                        "id": task_id,
                        "description": description,
                        "status": "failed"
                    }
                })
                
        except Exception as e:
            return self.format_xml_response({"error": f"Error executing task: {str(e)}"})

def main():
    """Main function to handle command line arguments and run the agent"""
    # Check for model argument
    model_name = "openrouter/deepseek/deepseek-r1"  # Default model
    
    # Look for --model or -m flag
    for i, arg in enumerate(sys.argv):
        if arg in ["--model", "-m"] and i + 1 < len(sys.argv):
            model_name = sys.argv[i + 1]
            # Remove these arguments
            sys.argv.pop(i)
            sys.argv.pop(i)
            break
    
    agent = Agent(model_name)
    
    if len(sys.argv) < 2:
        print("Usage: ./agent [--model MODEL_NAME] <command> [arguments]")
        print("Commands:")
        print("  init                  - Initialize the agent")
        print("  plan [spec_file]      - Generate a plan from specification (default: spec.md)")
        print("  display               - Display the current plan")
        print("  update <task_id> <status> [--notes=text] [--progress=0-100] - Update task status")
        print("  execute <task_id>     - Execute a specific task")
        print("\nOptions:")
        print("  --model, -m MODEL_NAME - Specify the model to use (default: openai/gpt-3.5-turbo)")
        print("                           Use 'r1' for native deepseek-reasoner API")
        sys.exit(1)
    
    command = sys.argv[1]
    
    if command == "init":
        agent.initialize()
        print("Agent initialized successfully")
    
    elif command == "plan":
        # Use spec.md by default if no file specified
        spec_file = sys.argv[2] if len(sys.argv) > 2 else "spec.md"
        print(f"Using specification file: {spec_file}")
        try:
            with open(spec_file, 'r') as f:
                spec = f.read()
            
            print(f"Using model: {agent.model_name}")
            agent.initialize()
            
            try:
                result = agent.generate_plan(spec)
                print(result)
                
                # Save the plan to a file
                with open("agent_plan.xml", 'w') as f:
                    f.write(result)
                print("Plan saved to agent_plan.xml")
            except KeyboardInterrupt:
                print("\nOperation cancelled by user")
                sys.exit(1)
            
        except FileNotFoundError:
            print(f"Error: Specification file '{spec_file}' not found")
            sys.exit(1)
    
    elif command == "display":
        # Load the plan from file
        try:
            with open("agent_plan.xml", 'r') as f:
                xml_content = f.read()
                agent.plan_tree = agent.extract_xml_from_response(xml_content, "plan")
            
            result = agent.display_plan_tree()
            print(result)
            
        except FileNotFoundError:
            print("Error: No plan file found. Generate a plan first.")
            sys.exit(1)
    
    elif command == "update":
        if len(sys.argv) < 4:
            print("Error: Missing task_id or status")
            sys.exit(1)
        
        task_id = sys.argv[2]
        status = sys.argv[3]
        
        # Check for progress and notes flags
        progress = None
        notes = None
        
        for i, arg in enumerate(sys.argv[4:], 4):
            if arg.startswith("--progress="):
                progress = arg.split("=")[1]
            elif arg.startswith("--notes="):
                notes = arg.split("=")[1]
            elif i == 4 and not arg.startswith("--"):
                # For backward compatibility, treat the fourth argument as notes
                notes = arg
        
        # Load the plan from file
        try:
            with open("agent_plan.xml", 'r') as f:
                xml_content = f.read()
                agent.plan_tree = agent.extract_xml_from_response(xml_content, "plan")
            
            result = agent.update_plan(task_id, status, notes, progress)
            print(result)
            
            # Save the updated plan
            with open("agent_plan.xml", 'w') as f:
                f.write(result)
            
        except FileNotFoundError:
            print("Error: No plan file found. Generate a plan first.")
            sys.exit(1)
    
    elif command == "execute":
        if len(sys.argv) < 3:
            print("Error: Missing task_id")
            sys.exit(1)
        
        task_id = sys.argv[2]
        
        # Load the plan from file
        try:
            with open("agent_plan.xml", 'r') as f:
                xml_content = f.read()
                agent.plan_tree = agent.extract_xml_from_response(xml_content, "plan")
            
            try:
                result = agent.execute_task(task_id)
                print(result)
                
                # Save the actions to a file
                with open(f"agent_actions_{task_id}.xml", 'w') as f:
                    f.write(result)
                print(f"Actions saved to agent_actions_{task_id}.xml")
                
                # Save the updated plan
                with open("agent_plan.xml", 'w') as f:
                    f.write(agent.format_xml_response({"plan": agent.plan_tree}))
            except KeyboardInterrupt:
                print("\nOperation cancelled by user")
                sys.exit(1)
            
        except FileNotFoundError:
            print("Error: No plan file found. Generate a plan first.")
            sys.exit(1)
    
    elif command == "interactive":
        print(f"Starting interactive mode with model: {agent.model_name}")
        agent.initialize()
        
        while True:
            try:
                user_input = input("\n> ")
                if user_input.lower() in ["exit", "quit", "q"]:
                    break
                
                # Simple command processing
                if user_input.startswith("/"):
                    parts = user_input[1:].split()
                    cmd = parts[0] if parts else ""
                    
                    if cmd == "plan" and len(parts) > 1:
                        spec_file = parts[1]
                        try:
                            with open(spec_file, 'r') as f:
                                spec = f.read()
                            result = agent.generate_plan(spec)
                            print(result)
                        except FileNotFoundError:
                            print(f"Error: File '{spec_file}' not found")
                    
                    elif cmd == "display":
                        result = agent.display_plan_tree()
                        print(result)
                    
                    elif cmd == "execute" and len(parts) > 1:
                        task_id = parts[1]
                        result = agent.execute_task(task_id)
                        print(result)
                    
                    elif cmd == "help":
                        print("Available commands:")
                        print("  /plan <spec_file> - Generate a plan from specification")
                        print("  /display - Display the current plan")
                        print("  /execute <task_id> - Execute a specific task")
                        print("  /help - Show this help")
                        print("  exit, quit, q - Exit interactive mode")
                    
                    else:
                        print("Unknown command. Type /help for available commands.")
                
                # Treat as a prompt to the model
                else:
                    response = agent.stream_reasoning(user_input)
                    # No need to print response as it's already streamed
            
            except KeyboardInterrupt:
                print("\nUse 'exit' or 'q' to quit")
            except Exception as e:
                print(f"Error: {e}")
    
    else:
        print(f"Error: Unknown command '{command}'")
        sys.exit(1)

if __name__ == "__main__":
    main()
