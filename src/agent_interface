#!/usr/bin/env python3
# Make sure this file is executable with: chmod +x agent_interface

import os
import sys
import json
import datetime
import subprocess
import platform
from typing import List, Optional, Dict, Tuple
import xml.etree.ElementTree as ET
from rich.console import Console
from rich.panel import Panel
from rich.tree import Tree
from rich.syntax import Syntax
from rich.prompt import Prompt
from rich.markdown import Markdown

# Import the Agent class directly
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)
from agent import Agent

class AgentInterface:
    def __init__(self):
        self.console = Console()
        self.agent = Agent()
        self.current_plan = None
        self.model_aliases = {
            "flash": "openrouter/google/gemini-2.0-flash-001",
            "r1": "deepseek/deepseek-reasoner",
            "claude": "openrouter/anthropic/claude-3.7-sonnet"
        }
        self.chat_history = []
        self.history_file = "chat_history.json"
        self.system_info = self.get_system_info()
        self.multiline_input_buffer = []
        self.multiline_input_mode = False
        self.load_chat_history()
    
    def get_system_info(self) -> Dict[str, str]:
        """Get system information"""
        info = {}
        try:
            info["platform"] = platform.platform()
        except Exception:
            info["platform"] = "unknown"
            
        try:
            info["python"] = platform.python_version()
        except Exception:
            info["python"] = "unknown"
            
        try:
            info["processor"] = platform.processor()
        except Exception:
            info["processor"] = "unknown"
            
        try:
            info["hostname"] = platform.node()
        except Exception:
            info["hostname"] = "unknown"
            
        try:
            info["shell"] = os.environ.get("SHELL", "unknown")
        except Exception:
            info["shell"] = "unknown"
            
        return info
    
    def display_welcome(self):
        """Display welcome message and instructions"""
        system_info_text = f"Running on: {self.system_info['platform']} | Python {self.system_info['python']} | {self.system_info['shell']}"
        
        self.console.print(Panel.fit(
            "[bold blue]Agent Interface[/bold blue]\n"
            "A simple interface for the agent planning system\n"
            "Type [bold]/help[/bold] for available commands\n"
            "Any text not starting with / will be sent directly to the model\n\n"
            f"[dim]{system_info_text}[/dim]",
            title="Welcome",
            border_style="blue"
        ))
    
    def display_help(self):
        """Display available commands"""
        self.console.print("[bold]Available Commands:[/bold]")
        self.console.print("")
        self.console.print("[bold green]/init[/bold green]", "- Initialize the agent")
        self.console.print("[bold green]/plan [spec_file][/bold green]", "- Generate a plan from specification (default: spec.md)")
        self.console.print("[bold green]/display[/bold green]", "- Display the current plan")
        self.console.print("[bold green]/update <task_id> <status> [--notes=text] [--progress=0-100][/bold green]", "- Update task status")
        self.console.print("[bold green]/execute <task_id>[/bold green]", "- Execute a specific task (with confirmation)")
        self.console.print("[bold green]/execute-ready[/bold green]", "- Execute all ready tasks in dependency order")
        self.console.print("[bold green]/modify-plan[/bold green]", "- Let the agent suggest modifications to the plan")
        self.console.print("[bold green]/model <model_name>[/bold green]", "- Change the model (aliases: flash, r1, claude)")
        self.console.print("[bold green]/history [count][/bold green]", "- Display chat history (default: last 10 messages)")
        self.console.print("[bold green]/clear-history[/bold green]", "- Clear the chat history")
        self.console.print("[bold green]/memory[/bold green]", "- Display the agent's memory")
        self.console.print("[bold green]/clear-memory[/bold green]", "- Clear the agent's memory")
        self.console.print("[bold green]/paste[/bold green]", "- Enter multiline paste mode (end with /end)")
        self.console.print("[bold green]/end[/bold green]", "- End multiline paste mode")
        self.console.print("[bold green]/help[/bold green]", "- Show this help")
        self.console.print("[bold green]/exit[/bold green]", "- Exit the interface")
        self.console.print("")
        self.console.print("[italic]Any text not starting with / will be sent directly to the model as a chat message[/italic]")
        self.console.print("[italic]For multiline input, use /paste to start and /end to finish[/italic]")
        self.console.print("")
        self.console.print("[bold]XML Input Format:[/bold]")
        self.console.print("You can also send messages in XML format for more structured input:")
        self.console.print("")
        self.console.print("[bold cyan]<user_message>Your message here</user_message>[/bold cyan]")
        self.console.print("[bold cyan]<file_request path=\"path/to/file.py\">Request to see a file</file_request>[/bold cyan]")
    
    def execute_action(self, action_element):
        """Execute a single action from the XML"""
        try:
            action_type = action_element.get("type", "unknown")
            path = action_element.get("path", "")
            command = action_element.get("command", "")
            
            # Determine syntax highlighting language based on file extension
            language = "python"  # default
            if path:
                ext = os.path.splitext(path)[1].lower()
                if ext in ['.js', '.jsx']:
                    language = "javascript"
                elif ext in ['.html', '.htm']:
                    language = "html"
                elif ext in ['.css']:
                    language = "css"
                elif ext in ['.json']:
                    language = "json"
                elif ext in ['.md']:
                    language = "markdown"
                elif ext in ['.sh']:
                    language = "bash"
                elif ext in ['.yml', '.yaml']:
                    language = "yaml"
            
            # Ask for confirmation before executing
            if action_type == "create_file":
                content = action_element.text.strip() if action_element.text else ""
                self.console.print(f"[bold cyan]Action:[/bold cyan] Create file '{path}'")
                self.console.print(Syntax(content, language, theme="monokai"))
                
            elif action_type == "modify_file":
                self.console.print(f"[bold cyan]Action:[/bold cyan] Modify file '{path}'")
                for change in action_element.findall("./change"):
                    original = change.find("original").text if change.find("original") is not None else ""
                    new = change.find("new").text if change.find("new") is not None else ""
                    self.console.print("[bold red]- Original:[/bold red]")
                    self.console.print(Syntax(original, language, theme="monokai"))
                    self.console.print("[bold green]+ New:[/bold green]")
                    self.console.print(Syntax(new, language, theme="monokai"))
                    
            elif action_type == "run_command":
                self.console.print(f"[bold cyan]Action:[/bold cyan] Run command '{command}'")
            
            # Ask for confirmation
            confirm = Prompt.ask(
                "\nExecute this action?", 
                choices=["Y", "n"], 
                default="Y"
            )
                
            if confirm.lower() != "y":
                self.console.print("[bold yellow]Action skipped[/bold yellow]")
                return False
            
            # Execute the action
            if action_type == "create_file":
                # Create the file with the content
                content = action_element.text.strip() if action_element.text else ""
                
                # Create directory if it doesn't exist
                directory = os.path.dirname(path)
                if directory and not os.path.exists(directory):
                    os.makedirs(directory)
                    self.console.print(f"[bold green]Created directory: {directory}[/bold green]")
                
                with open(path, 'w') as f:
                    f.write(content)
                self.console.print(f"[bold green]Created file: {path}[/bold green]")
                
                # Make executable if it's a script
                if path.endswith('.py') or not os.path.splitext(path)[1]:
                    os.chmod(path, 0o755)
                    self.console.print(f"[bold green]Made file executable: {path}[/bold green]")
                
                return True
                
            elif action_type == "modify_file":
                if not os.path.exists(path):
                    self.console.print(f"[bold red]Error: File {path} does not exist[/bold red]")
                    return False
                
                # Read the original file
                with open(path, 'r') as f:
                    file_content = f.read()
                
                # Apply each change
                changes_applied = False
                for change in action_element.findall("./change"):
                    original = change.find("original").text if change.find("original") is not None else ""
                    new = change.find("new").text if change.find("new") is not None else ""
                    
                    if original in file_content:
                        file_content = file_content.replace(original, new)
                        changes_applied = True
                    else:
                        self.console.print(f"[bold yellow]Warning: Could not find text to replace in {path}[/bold yellow]")
                
                # Write the modified content back
                if changes_applied:
                    with open(path, 'w') as f:
                        f.write(file_content)
                    self.console.print(f"[bold green]Modified file: {path}[/bold green]")
                    return True
                else:
                    self.console.print(f"[bold yellow]No changes applied to {path}[/bold yellow]")
                    return False
                
            elif action_type == "run_command":
                self.console.print(f"[bold blue]Running command: {command}[/bold blue]")
                
                # Run the command and capture output
                process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                
                # Stream output in real-time
                for line in process.stdout:
                    self.console.print(line.rstrip())
                
                # Wait for process to complete
                process.wait()
                
                if process.returncode == 0:
                    self.console.print(f"[bold green]Command completed successfully[/bold green]")
                    return True
                else:
                    stderr = process.stderr.read()
                    self.console.print(f"[bold red]Command failed with exit code {process.returncode}[/bold red]")
                    if stderr:
                        self.console.print(f"[bold red]Error: {stderr}[/bold red]")
                    return False
            
            else:
                self.console.print(f"[bold yellow]Unknown action type: {action_type}[/bold yellow]")
                return False
                
        except Exception as e:
            self.console.print(f"[bold red]Error executing action: {e}[/bold red]")
            return False
    
    def update_dependent_tasks(self, root, completed_task_id):
        """Update tasks that depend on the completed task"""
        # Find all tasks that depend on the completed task
        for task in root.findall(".//task"):
            depends_on = task.get("depends_on", "")
            if depends_on:
                dependencies = [dep.strip() for dep in depends_on.split(",")]
                if completed_task_id in dependencies:
                    # Check if all dependencies are completed
                    all_deps_completed = True
                    for dep_id in dependencies:
                        if dep_id == completed_task_id:
                            continue  # This one is completed
                        
                        dep_task = root.find(f".//task[@id='{dep_id}']")
                        if dep_task is None or dep_task.get("status") != "completed":
                            all_deps_completed = False
                            break
                    
                    # If all dependencies are completed, mark this task as ready
                    if all_deps_completed:
                        current_status = task.get("status", "pending")
                        if current_status == "pending":
                            task.set("status", "ready")
                            self.console.print(f"[bold blue]Task {task.get('id')} is now ready to be executed[/bold blue]")
    
    def display_plan_tree(self, xml_content: str):
        """Display the plan as a rich tree"""
        try:
            # Parse the XML
            root = ET.fromstring(xml_content)
            plan_element = root.find(".//plan")
            
            if plan_element is None:
                self.console.print("[bold red]Error:[/bold red] No plan found in XML")
                return
            
            # Create a rich tree
            tree = Tree("[bold blue]Plan[/bold blue]")
            
            # Process tasks recursively
            def add_tasks(parent_element, parent_tree):
                for task in parent_element.findall("./task"):
                    task_id = task.get("id", "unknown")
                    description = task.get("description", "No description")
                    status = task.get("status", "pending")
                    complexity = task.get("complexity", "unknown")
                    
                    # Choose color based on status
                    status_color = {
                        "pending": "yellow",
                        "in-progress": "blue",
                        "completed": "green",
                        "failed": "red"
                    }.get(status, "white")
                    
                    # Get dependencies and progress
                    depends_on = task.get("depends_on", "")
                    progress = task.get("progress", "0")
                    
                    # Create task node
                    task_text = f"[bold]{task_id}[/bold]: {description} "
                    task_text += f"[{status_color}]({status})[/{status_color}]"
                    
                    # Add progress bar if available
                    if progress and progress.isdigit():
                        progress_int = int(progress)
                        progress_bar = "█" * (progress_int // 10) + "░" * (10 - (progress_int // 10))
                        task_text += f" [{status_color}]{progress_bar} {progress}%[/{status_color}]"
                    
                    task_text += f" [dim]complexity: {complexity}[/dim]"
                    
                    # Add dependencies if present
                    if depends_on:
                        task_text += f" [dim italic]depends on: {depends_on}[/dim italic]"
                    
                    task_node = parent_tree.add(task_text)
                    
                    # Add notes if present
                    notes = task.get("notes")
                    if notes:
                        task_node.add(f"[italic dim]Notes: {notes}[/italic dim]")
                    
                    # Process subtasks
                    add_tasks(task, task_node)
            
            # Start with the root task
            root_task = plan_element.find("./task")
            if root_task is not None:
                add_tasks(plan_element, tree)
            
            # Display the tree
            self.console.print(tree)
            
        except ET.ParseError as e:
            self.console.print(f"[bold red]Error parsing XML:[/bold red] {e}")
        except Exception as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")
    
    def run_command(self, command: List[str], is_slash_command: bool = True):
        """Run a command and handle the result"""
        if not command:
            return
        
        cmd = command[0].lower()
        args = command[1:]
        
        # If not a slash command, treat as chat with the model
        if not is_slash_command:
            self.chat_with_model(" ".join([cmd] + args))
            return
        
        # Handle paste mode commands
        if cmd == "paste":
            self.multiline_input_mode = True
            self.multiline_input_buffer = []
            self.console.print("[bold yellow]Entering multiline paste mode. Type /end when finished.[/bold yellow]")
            return
        
        if cmd == "end":
            if self.multiline_input_mode:
                self.multiline_input_mode = False
                if self.multiline_input_buffer:
                    full_input = "\n".join(self.multiline_input_buffer)
                    self.console.print(f"[dim]Processing {len(self.multiline_input_buffer)} lines of input...[/dim]")
                    self.chat_with_model(full_input)
                    self.multiline_input_buffer = []
                else:
                    self.console.print("[yellow]No input to process[/yellow]")
            else:
                self.console.print("[yellow]Not in paste mode[/yellow]")
            return
        
        # Handle memory commands
        if cmd == "memory":
            memory_content = self._load_persistent_memory()
            try:
                # Format the XML for display
                memory_root = ET.fromstring(memory_content)
                formatted_memory = self.agent.pretty_format_xml(ET.tostring(memory_root, encoding='unicode'))
                
                # Display as syntax-highlighted XML
                self.console.print("[bold blue]Agent Memory:[/bold blue]")
                self.console.print(Syntax(formatted_memory, "xml", theme="monokai"))
            except ET.ParseError as e:
                self.console.print(f"[bold red]Error parsing memory XML: {e}[/bold red]")
                self.console.print(memory_content)
            return
            
        if cmd == "clear-memory":
            confirm = Prompt.ask(
                "Are you sure you want to clear the agent's memory?", 
                choices=["y", "n"], 
                default="n"
            )
            
            if confirm.lower() == "y":
                # Create default memory structure - simple and flexible
                default_memory = "<memory>\n  <!-- Agent can structure this as needed -->\n</memory>"
                with open("agent_memory.xml", 'w') as f:
                    f.write(default_memory)
                self.console.print("[bold green]Agent memory cleared[/bold green]")
            else:
                self.console.print("[bold yellow]Operation cancelled[/bold yellow]")
            return
        
        if cmd == "help":
            self.display_help()
        
        elif cmd == "exit":
            self.console.print("[bold blue]Exiting...[/bold blue]")
            sys.exit(0)
        
        elif cmd == "init":
            with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                self.agent.initialize()
            self.console.print("[bold green]Agent initialized successfully[/bold green]")
        
        elif cmd == "modify-plan":
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            self.console.print("[bold blue]Asking agent to suggest plan modifications...[/bold blue]")
            
            try:
                # Get the current plan status
                root = ET.fromstring(self.agent.plan_tree)
                
                # Count tasks by status
                status_counts = {"pending": 0, "ready": 0, "in-progress": 0, "completed": 0, "failed": 0}
                for task in root.findall(".//task"):
                    status = task.get("status", "pending")
                    if status in status_counts:
                        status_counts[status] += 1
                
                # Generate a prompt for the agent
                prompt = f"""
                Review the current plan and suggest modifications based on the current state.
                
                CURRENT PLAN STATUS:
                - Pending tasks: {status_counts["pending"]}
                - Ready tasks: {status_counts["ready"]}
                - In-progress tasks: {status_counts["in-progress"]}
                - Completed tasks: {status_counts["completed"]}
                - Failed tasks: {status_counts["failed"]}
                
                CURRENT PLAN:
                {self.agent.plan_tree}
                
                Based on the current state, suggest modifications to the plan. These could include:
                - Adding new tasks that were not initially considered
                - Modifying existing tasks based on what we've learned
                - Removing tasks that are no longer necessary
                - Adjusting dependencies between tasks
                
                Return your suggestions in this XML format:
                
                <plan_update>
                  <add_task parent_id="task1" id="task1.3" description="New subtask" status="pending" complexity="medium" depends_on="" progress="0" />
                  <modify_task id="task2" description="Updated description" />
                  <remove_task id="task3" />
                </plan_update>
                
                Only include changes that are necessary. If no changes are needed, return an empty plan_update element.
                """
                
                # Stream the reasoning process
                response = self.agent.stream_reasoning(prompt)
                
                # Extract plan_update XML from the response
                plan_update_xml = self.agent.extract_xml_from_response(response, "plan_update")
                
                if plan_update_xml:
                    # Parse the plan update
                    update_root = ET.fromstring(plan_update_xml)
                    
                    # Count the number of changes
                    add_tasks = update_root.findall("./add_task")
                    modify_tasks = update_root.findall("./modify_task")
                    remove_tasks = update_root.findall("./remove_task")
                    
                    total_changes = len(add_tasks) + len(modify_tasks) + len(remove_tasks)
                    
                    if total_changes == 0:
                        self.console.print("[bold green]No changes suggested by the agent[/bold green]")
                        return
                    
                    # Display the suggested changes
                    self.console.print(f"[bold blue]Agent suggests {total_changes} changes:[/bold blue]")
                    
                    for add_task in add_tasks:
                        parent_id = add_task.get("parent_id", "unknown")
                        task_id = add_task.get("id", "unknown")
                        description = add_task.get("description", "No description")
                        self.console.print(f"[bold green]+ Add task {task_id}[/bold green] to parent {parent_id}: {description}")
                    
                    for modify_task in modify_tasks:
                        task_id = modify_task.get("id", "unknown")
                        description = modify_task.get("description", "")
                        self.console.print(f"[bold yellow]~ Modify task {task_id}[/bold yellow]" + (f": {description}" if description else ""))
                    
                    for remove_task in remove_tasks:
                        task_id = remove_task.get("id", "unknown")
                        self.console.print(f"[bold red]- Remove task {task_id}[/bold red]")
                    
                    # Ask for confirmation
                    confirm = Prompt.ask(
                        "\nApply these changes?", 
                        choices=["y", "n"], 
                        default="n"
                    )
                    
                    if confirm.lower() == "y":
                        # Apply the changes
                        self.agent.apply_plan_updates(plan_update_xml)
                        
                        # Save the updated plan
                        with open("agent_plan.xml", 'w') as f:
                            f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                        
                        self.console.print("[bold green]Plan updated successfully[/bold green]")
                        
                        # Display the updated plan
                        self.display_plan_tree(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                    else:
                        self.console.print("[bold yellow]Changes discarded[/bold yellow]")
                else:
                    self.console.print("[bold yellow]No plan updates found in the response[/bold yellow]")
            
            except Exception as e:
                self.console.print(f"[bold red]Error modifying plan: {e}[/bold red]")
        
        elif cmd == "history":
            # Display chat history
            count = 10  # Default to last 10 messages
            if args and args[0].isdigit():
                count = int(args[0])
            
            if not self.chat_history:
                self.console.print("[bold yellow]No chat history available[/bold yellow]")
                return
            
            # Get the specified number of messages from the end of history
            messages_to_show = self.chat_history[-count:] if len(self.chat_history) > count else self.chat_history
            
            self.console.print(f"[bold blue]Chat History (last {len(messages_to_show)} messages):[/bold blue]")
            for i, msg in enumerate(messages_to_show):
                role = msg["role"]
                content = msg["content"]
                timestamp = msg.get("timestamp", "")
                
                # Format timestamp if available
                time_str = ""
                if timestamp:
                    try:
                        dt = datetime.datetime.fromisoformat(timestamp)
                        time_str = f"[dim]{dt.strftime('%Y-%m-%d %H:%M:%S')}[/dim]"
                    except:
                        time_str = f"[dim]{timestamp}[/dim]"
                
                # Format based on role
                if role == "user":
                    self.console.print(f"\n{time_str}")
                    self.console.print(f"[bold green]User:[/bold green] {content}")
                else:
                    self.console.print(f"\n{time_str}")
                    
                    # For assistant messages, try to extract and format the message part
                    message_xml = self.agent.extract_xml_from_response(content, "message")
                    if message_xml:
                        try:
                            root = ET.fromstring(message_xml)
                            message_text = root.text if root.text else ""
                            self.console.print(f"[bold blue]Assistant:[/bold blue]")
                            self.console.print(Markdown(message_text))
                        except ET.ParseError:
                            self.console.print(f"[bold blue]Assistant:[/bold blue] {content[:100]}...")
                    else:
                        self.console.print(f"[bold blue]Assistant:[/bold blue] {content[:100]}...")
        
        elif cmd == "clear-history":
            confirm = Prompt.ask(
                "Are you sure you want to clear the chat history?", 
                choices=["y", "n"], 
                default="n"
            )
            
            if confirm.lower() == "y":
                self.chat_history = []
                self.save_chat_history()
                self.console.print("[bold green]Chat history cleared[/bold green]")
            else:
                self.console.print("[bold yellow]Operation cancelled[/bold yellow]")
                
        elif cmd == "model":
            if not args:
                self.console.print(f"[bold blue]Current model:[/bold blue] {self.agent.model_name}")
                return
                
            model_name = args[0]
            
            # Check for model aliases
            if model_name in self.model_aliases:
                model_name = self.model_aliases[model_name]
                
            self.agent.model_name = model_name
            self.console.print(f"[bold green]Model changed to:[/bold green] {self.agent.model_name}")
        
        elif cmd == "plan":
            # Use spec.md by default if no file specified
            spec_file = args[0] if args else "spec.md"
            self.console.print(f"[bold blue]Using specification file:[/bold blue] {spec_file}")
            try:
                with open(spec_file, 'r') as f:
                    spec = f.read()
                
                self.console.print(f"[bold blue]Using model:[/bold blue] {self.agent.model_name}")
                
                # Initialize if not already done
                if not self.agent.repository_info:
                    with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                        self.agent.initialize()
                
                # Generate plan - don't use status context manager to allow streaming
                self.console.print("[bold blue]Generating plan...[/bold blue]")
                try:
                    # Set a callback to handle streaming in the interface
                    def stream_callback(content, is_reasoning=False):
                        if is_reasoning:
                            # Use yellow color for reasoning tokens
                            self.console.print(f"[yellow]{content}[/yellow]", end="")
                        else:
                            # Use rich for normal content
                            self.console.print(content, end="", highlight=False)
                            
                    # Pass the callback to the agent
                    self.agent.stream_callback = stream_callback
                    result = self.agent.generate_plan(spec)
                            
                    # Save the plan to a file
                    with open("agent_plan.xml", 'w') as f:
                        f.write(result)
                            
                    # Extract plan XML for display
                    plan_xml = self.agent.extract_xml_from_response(result, "plan")
                    if plan_xml:
                        self.current_plan = result
                        self.console.print("\n\n[bold blue]Generated Plan:[/bold blue]")
                        self.display_plan_tree(result)
                    else:
                        self.console.print("[bold red]Error:[/bold red] No plan found in response")
                                
                    self.console.print("[bold green]Plan saved to agent_plan.xml[/bold green]")
                            
                except KeyboardInterrupt:
                    self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
                
            except FileNotFoundError:
                self.console.print(f"[bold red]Error:[/bold red] Specification file '{spec_file}' not found")
        
        elif cmd == "display":
            # Load the plan from file if not already loaded
            if not self.current_plan:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                        self.current_plan = xml_content
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            self.display_plan_tree(self.current_plan)
        
        elif cmd == "update":
            if len(args) < 2:
                self.console.print("[bold red]Error:[/bold red] Missing task_id or status")
                return
            
            task_id = args[0]
            status = args[1]
            
            # Check for progress and notes flags
            progress = None
            notes = None
            
            for i, arg in enumerate(args[2:], 2):
                if arg.startswith("--progress="):
                    progress = arg.split("=")[1]
                elif arg.startswith("--notes="):
                    notes = arg.split("=")[1]
                elif i == 2 and not arg.startswith("--"):
                    # For backward compatibility, treat the third argument as notes
                    notes = arg
            
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            with self.console.status(f"[bold blue]Updating task {task_id}...[/bold blue]"):
                result = self.agent.update_plan(task_id, status, notes, progress)
            
            # Save the updated plan
            with open("agent_plan.xml", 'w') as f:
                f.write(result)
            
            self.current_plan = result
            self.console.print(f"[bold green]Task {task_id} updated to {status}[/bold green]")
            self.display_plan_tree(result)
        
        elif cmd == "execute-ready":
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            # Find all ready tasks
            try:
                root = ET.fromstring(self.agent.plan_tree)
                ready_tasks = []
                
                # First pass: find all tasks with status "ready" or "pending" with no dependencies
                for task in root.findall(".//task"):
                    task_id = task.get("id")
                    status = task.get("status", "pending")
                    depends_on = task.get("depends_on", "")
                    
                    if status == "ready" or (status == "pending" and not depends_on):
                        # Check if dependencies are met
                        deps_met, _ = self.agent.check_dependencies(task_id)
                        if deps_met:
                            ready_tasks.append((task_id, task.get("description", "")))
                
                if not ready_tasks:
                    self.console.print("[bold yellow]No ready tasks found[/bold yellow]")
                    return
                
                # Display ready tasks
                self.console.print("[bold blue]Ready tasks:[/bold blue]")
                for i, (task_id, desc) in enumerate(ready_tasks):
                    self.console.print(f"[bold]{i+1}.[/bold] {task_id}: {desc}")
                
                # Ask which tasks to execute
                confirm = Prompt.ask(
                    "\nExecute all ready tasks?", 
                    choices=["y", "n", "select"], 
                    default="n"
                )
                
                if confirm.lower() == "n":
                    self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                    return
                
                tasks_to_execute = []
                
                if confirm.lower() == "select":
                    # Let user select specific tasks
                    selection = Prompt.ask(
                        "Enter task numbers to execute (comma-separated)", 
                        default="1"
                    )
                    try:
                        selected_indices = [int(idx.strip()) - 1 for idx in selection.split(",")]
                        for idx in selected_indices:
                            if 0 <= idx < len(ready_tasks):
                                tasks_to_execute.append(ready_tasks[idx][0])  # Add task_id
                    except ValueError:
                        self.console.print("[bold red]Invalid selection[/bold red]")
                        return
                else:
                    # Execute all ready tasks
                    tasks_to_execute = [task[0] for task in ready_tasks]  # Get all task_ids
                
                # Execute each selected task
                for task_id in tasks_to_execute:
                    self.console.print(f"\n[bold blue]Executing task {task_id}...[/bold blue]")
                    
                    try:
                        result = self.agent.execute_task(task_id)
                        
                        # Check for errors
                        error_element = ET.fromstring(result).find(".//error")
                        if error_element is not None and error_element.text:
                            self.console.print(f"[bold red]Error:[/bold red] {error_element.text}")
                            continue
                        
                        # Save the actions to a file
                        with open(f"agent_actions_{task_id}.xml", 'w') as f:
                            f.write(result)
                        
                        # Save the updated plan
                        with open("agent_plan.xml", 'w') as f:
                            f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                        
                        # Display the actions
                        actions_xml = self.agent.extract_xml_from_response(result, "actions")
                        if actions_xml:
                            # Parse the actions to show them individually for confirmation
                            try:
                                actions_root = ET.fromstring(actions_xml)
                                actions_count = len(actions_root.findall("./action"))
                                
                                # Ask if user wants to execute all actions or confirm each one
                                if actions_count > 1:
                                    execute_mode = Prompt.ask(
                                        "\nHow do you want to execute actions?", 
                                        choices=["all", "one-by-one", "cancel"], 
                                        default="one-by-one"
                                    )
                                    
                                    if execute_mode == "cancel":
                                        self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                                        continue
                                else:
                                    execute_mode = "one-by-one"
                                
                                successful_actions = 0
                                
                                if execute_mode == "all":
                                    # Execute all actions with a single confirmation
                                    confirm = Prompt.ask(
                                        f"\nExecute all {actions_count} actions?", 
                                        choices=["y", "n"], 
                                        default="n"
                                    )
                                    
                                    if confirm.lower() == "y":
                                        with self.console.status(f"[bold blue]Executing {actions_count} actions...[/bold blue]"):
                                            for i, action in enumerate(actions_root.findall("./action")):
                                                self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                                                if self.execute_action(action):
                                                    successful_actions += 1
                                    else:
                                        self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                                        continue
                                else:
                                    # Execute actions one by one with confirmation for each
                                    for i, action in enumerate(actions_root.findall("./action")):
                                        self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                                        
                                        # Execute the action with confirmation
                                        if self.execute_action(action):
                                            successful_actions += 1
                                
                                # Update task progress based on completed actions
                                if actions_count > 0:
                                    completion_percentage = int((successful_actions / actions_count) * 30) + 70
                                    if successful_actions == actions_count:
                                        # All actions completed successfully
                                        self.console.print("[bold green]All actions completed successfully[/bold green]")
                                        
                                        # Parse the plan tree
                                        root = ET.fromstring(self.agent.plan_tree)
                                        task_element = root.find(f".//task[@id='{task_id}']")
                                        if task_element is not None:
                                            task_element.set("status", "completed")
                                            task_element.set("progress", "100")
                                            
                                            # Update dependent tasks to be ready
                                            self.update_dependent_tasks(root, task_id)
                                            
                                            self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                            
                                            # Save the updated plan
                                            with open("agent_plan.xml", 'w') as f:
                                                f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                            
                                            self.console.print(f"[bold green]Task {task_id} marked as completed[/bold green]")
                                    else:
                                        # Some actions failed
                                        self.console.print(f"[bold yellow]{successful_actions}/{actions_count} actions completed[/bold yellow]")
                                        
                                        # Parse the plan tree
                                        root = ET.fromstring(self.agent.plan_tree)
                                        task_element = root.find(f".//task[@id='{task_id}']")
                                        if task_element is not None:
                                            task_element.set("progress", str(completion_percentage))
                                            self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                            
                                            # Save the updated plan
                                            with open("agent_plan.xml", 'w') as f:
                                                f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                            
                                            self.console.print(f"[bold yellow]Task {task_id} progress updated to {completion_percentage}%[/bold yellow]")
                            
                            except ET.ParseError:
                                self.console.print("[bold red]Error parsing actions XML[/bold red]")
                        
                        self.console.print(f"[bold green]Actions saved to agent_actions_{task_id}.xml[/bold green]")
                        
                    except KeyboardInterrupt:
                        self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
                        break
                    except Exception as e:
                        self.console.print(f"[bold red]Error executing task {task_id}: {e}[/bold red]")
                
                # Display the updated plan
                self.display_plan_tree(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                
            except ET.ParseError:
                self.console.print("[bold red]Error parsing plan XML[/bold red]")
            except Exception as e:
                self.console.print(f"[bold red]Error: {e}[/bold red]")
        
        elif cmd == "execute":
            if not args:
                self.console.print("[bold red]Error:[/bold red] Missing task_id")
                return
            
            task_id = args[0]
            
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            # Check dependencies first
            deps_met, missing_deps = self.agent.check_dependencies(task_id)
            if not deps_met:
                self.console.print("[bold red]Error:[/bold red] Dependencies not met")
                for dep in missing_deps:
                    self.console.print(f"[bold yellow]- {dep}[/bold yellow]")
                
                confirm = Prompt.ask(
                    "\nContinue anyway?", 
                    choices=["y", "n"], 
                    default="n"
                )
                if confirm.lower() != "y":
                    self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                    return
            
            self.console.print(f"[bold blue]Executing task {task_id}...[/bold blue]")
            
            try:
                result = self.agent.execute_task(task_id)
                
                # Check for errors
                error_element = ET.fromstring(result).find(".//error")
                if error_element is not None and error_element.text:
                    self.console.print(f"[bold red]Error:[/bold red] {error_element.text}")
                    return
                
                # Save the actions to a file
                with open(f"agent_actions_{task_id}.xml", 'w') as f:
                    f.write(result)
                
                # Save the updated plan
                with open("agent_plan.xml", 'w') as f:
                    f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                
                # Display the actions
                actions_xml = self.agent.extract_xml_from_response(result, "actions")
                if actions_xml:
                    # Clean up XML for display
                    try:
                        root = ET.fromstring(actions_xml)
                        clean_xml = ET.tostring(root, encoding='unicode')
                        syntax = Syntax(clean_xml, "xml", theme="monokai", line_numbers=True)
                        self.console.print(Panel(syntax, title=f"Actions for Task {task_id}", border_style="green"))
                    except ET.ParseError:
                        # Fallback if XML parsing fails
                        syntax = Syntax(actions_xml, "xml", theme="monokai", line_numbers=True)
                        self.console.print(Panel(syntax, title=f"Actions for Task {task_id}", border_style="green"))
                    
                    # Parse the actions to show them individually for confirmation
                    try:
                        actions_root = ET.fromstring(actions_xml)
                        actions_count = len(actions_root.findall("./action"))
                            
                        # Ask if user wants to execute all actions or confirm each one
                        if actions_count > 1:
                            execute_mode = Prompt.ask(
                                "\nHow do you want to execute actions?", 
                                choices=["all", "one-by-one", "cancel"], 
                                default="one-by-one"
                            )
                                
                            if execute_mode == "cancel":
                                self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                                return
                        else:
                            execute_mode = "one-by-one"
                            
                        successful_actions = 0
                            
                        if execute_mode == "all":
                            # Execute all actions with a single confirmation
                            confirm = Prompt.ask(
                                f"\nExecute all {actions_count} actions?", 
                                choices=["y", "n"], 
                                default="n"
                            )
                                
                            if confirm.lower() == "y":
                                with self.console.status(f"[bold blue]Executing {actions_count} actions...[/bold blue]"):
                                    for i, action in enumerate(actions_root.findall("./action")):
                                        self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                                        if self.execute_action(action):
                                            successful_actions += 1
                            else:
                                self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                                return
                        else:
                            # Execute actions one by one with confirmation for each
                            for i, action in enumerate(actions_root.findall("./action")):
                                self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                                    
                                # Execute the action with confirmation
                                if self.execute_action(action):
                                    successful_actions += 1
                            
                        # Update task progress based on completed actions
                        if actions_count > 0:
                            completion_percentage = int((successful_actions / actions_count) * 30) + 70
                            if successful_actions == actions_count:
                                # All actions completed successfully
                                self.console.print("[bold green]All actions completed successfully[/bold green]")
                                    
                                # Parse the plan tree
                                root = ET.fromstring(self.agent.plan_tree)
                                task_element = root.find(f".//task[@id='{task_id}']")
                                if task_element is not None:
                                    task_element.set("status", "completed")
                                    task_element.set("progress", "100")
                                        
                                    # Update dependent tasks to be ready
                                    self.update_dependent_tasks(root, task_id)
                                        
                                    self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                        
                                    # Save the updated plan
                                    with open("agent_plan.xml", 'w') as f:
                                        f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                        
                                    self.console.print(f"[bold green]Task {task_id} marked as completed[/bold green]")
                            else:
                                # Some actions failed
                                self.console.print(f"[bold yellow]{successful_actions}/{actions_count} actions completed[/bold yellow]")
                                    
                                # Parse the plan tree
                                root = ET.fromstring(self.agent.plan_tree)
                                task_element = root.find(f".//task[@id='{task_id}']")
                                if task_element is not None:
                                    task_element.set("progress", str(completion_percentage))
                                    self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                        
                                    # Save the updated plan
                                    with open("agent_plan.xml", 'w') as f:
                                        f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                        
                                    self.console.print(f"[bold yellow]Task {task_id} progress updated to {completion_percentage}%[/bold yellow]")
                    
                    except ET.ParseError:
                        self.console.print("[bold red]Error parsing actions XML[/bold red]")
                
                self.console.print(f"[bold green]Actions saved to agent_actions_{task_id}.xml[/bold green]")
                
            except KeyboardInterrupt:
                self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
        
        else:
            self.console.print(f"[bold red]Unknown command:[/bold red] {cmd}")
            self.console.print("Type [bold]help[/bold] for available commands")
    
    def execute_shell_command(self, command: str, auto_run: bool = False) -> Tuple[bool, str]:
        """Execute a shell command with optional auto-run"""
        self.console.print(f"[bold cyan]Shell Command:[/bold cyan] {command}")
        
        execution_context = {
            "command": command,
            "auto_run": auto_run,
            "user_approved": False,
            "success": False,
            "output": "",
            "error": "",
            "return_code": None,
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        if not auto_run:
            confirm = Prompt.ask(
                "\nExecute this shell command?", 
                choices=["Y", "n"], 
                default="Y"
            )
            
            if confirm.lower() != "y":
                self.console.print("[bold yellow]Command execution skipped[/bold yellow]")
                execution_context["user_approved"] = False
                return False, self._format_execution_context(execution_context)
            
            execution_context["user_approved"] = True
        else:
            execution_context["user_approved"] = True
        
        self.console.print(f"[bold blue]Running command: {command}[/bold blue]")
        
        # Run the command and capture output
        process = subprocess.Popen(
            command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        # Collect output while streaming
        output_lines = []
        
        # Stream output in real-time
        for line in process.stdout:
            output_lines.append(line.rstrip())
            self.console.print(line.rstrip())
        
        # Wait for process to complete
        process.wait()
        
        # Get stderr if any
        stderr = process.stderr.read()
        
        # Truncate output to last 5000 characters
        full_output = "\n".join(output_lines)
        if len(full_output) > 5000:
            truncated_output = "... (output truncated) ...\n" + full_output[-5000:]
        else:
            truncated_output = full_output
            
        execution_context["output"] = truncated_output
        execution_context["error"] = stderr
        execution_context["return_code"] = process.returncode
        execution_context["success"] = (process.returncode == 0)
        
        if process.returncode == 0:
            self.console.print(f"[bold green]Command completed successfully[/bold green]")
            return True, self._format_execution_context(execution_context)
        else:
            self.console.print(f"[bold red]Command failed with exit code {process.returncode}[/bold red]")
            if stderr:
                self.console.print(f"[bold red]Error: {stderr}[/bold red]")
            return False, self._format_execution_context(execution_context)
    
    def _format_execution_context(self, context: Dict) -> str:
        """Format execution context as XML"""
        xml = f"""<execution_context>
  <command>{context['command']}</command>
  <auto_run>{str(context['auto_run']).lower()}</auto_run>
  <user_approved>{str(context['user_approved']).lower()}</user_approved>
  <success>{str(context['success']).lower()}</success>
  <return_code>{context['return_code']}</return_code>
  <timestamp>{context['timestamp']}</timestamp>
  <output><![CDATA[{context['output']}]]></output>
  <error><![CDATA[{context['error']}]]></error>
</execution_context>"""
        return xml
        
    def _get_terminal_height(self) -> int:
        """Get the terminal height for proper screen clearing"""
        try:
            import shutil
            terminal_size = shutil.get_terminal_size()
            return terminal_size.lines
        except Exception:
            # Fallback to a reasonable default if we can't get the terminal size
            return 40
    
    def load_chat_history(self):
        """Load chat history from file if it exists"""
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    self.chat_history = json.load(f)
                    self.console.print(f"[dim]Loaded {len(self.chat_history)} previous messages[/dim]")
        except Exception as e:
            self.console.print(f"[dim]Could not load chat history: {e}[/dim]")
            self.chat_history = []
    
    def save_chat_history(self):
        """Save chat history to file"""
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.chat_history, f, indent=2)
        except Exception as e:
            self.console.print(f"[dim]Could not save chat history: {e}[/dim]")
    
    def chat_with_model(self, message: str):
        """Send a message directly to the model and handle the response"""
        # Move existing text up and clear remaining space
        terminal_height = self._get_terminal_height()
        # Move cursor up by terminal height and clear from cursor down
        print(f"\x1b[{terminal_height}F\x1b[J", end="")
        
        # Initialize agent if not already done
        if not self.agent.repository_info:
            with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                self.agent.initialize()
        
        # Format user message as XML if it's not already
        if not message.strip().startswith("<"):
            formatted_message = f"<user_message>{message}</user_message>"
        else:
            formatted_message = message
        
        # Add user message to history
        timestamp = datetime.datetime.now().isoformat()
        self.chat_history.append({
            "role": "user",
            "content": formatted_message,
            "timestamp": timestamp
        })
        self.save_chat_history()
        
        # Print the full message being sent to the model
        print("\n=== Message Sent to Model ===\n")
        print(f"Model: {self.agent.model_name}")
        
        # Get current date, time and timezone
        now = datetime.datetime.now()
        timezone = datetime.datetime.now().astimezone().tzinfo
        
        # Load persistent memory if it exists
        memory_content = self._load_persistent_memory()
        
        # Construct a prompt that instructs the model to respond in XML format
        prompt = f"""
        <context>
          <system_info>
            <date>{now.strftime('%Y-%m-%d')}</date>
            <time>{now.strftime('%H:%M:%S')}</time>
            <timezone>{timezone}</timezone>
            <platform>{self.system_info['platform']}</platform>
            <shell>{self.system_info['shell']}</shell>
          </system_info>
          <conversation_history>
            {self._format_history_for_prompt()}
          </conversation_history>
          <memory>
            {memory_content}
          </memory>
          {formatted_message}
        </context>
        
        You are an AI assistant that can respond to user queries and also perform actions.
        
        You can respond in the following ways:
        
        1. Simple message:
        <message>Your response text here</message>
        
        2. Actions to execute:
        <actions>
          <action type="create_file" path="example.py">
            # Python code here
          </action>
          <action type="modify_file" path="existing.py">
            <change>
              <original>def old_function():</original>
              <new>def new_function():</new>
            </change>
          </action>
        </actions>
        
        3. File edits (search and replace):
        <file_edits>
          <edit path="path/to/file.py">
            <search>def old_function():</search>
            <replace>def new_function():</replace>
          </edit>
          <edit path="path/to/new_file.py">
            <search></search>
            <replace># New file content here</replace>
          </edit>
        </file_edits>
        
        4. Shell commands:
        <shell_commands>
          <command safe_to_autorun="true">echo "Hello World"</command>
          <command safe_to_autorun="false">rm -rf some_directory</command>
        </shell_commands>
        
        5. Memory updates:
        <memory_updates>
          <edit>
            <search>Old information to replace</search>
            <replace>Updated information</replace>
          </edit>
          <append>New information to remember</append>
        </memory_updates>
        
        6. Execution status:
        <execution_status complete="true|false" needs_user_input="true|false">
          <message>Status message explaining what's done or what's needed</message>
        </execution_status>
        
        You can include multiple response types in a single reply.
        For shell commands, set safe_to_autorun="true" only for commands that are completely safe and have no destructive potential.
        
        When you need to update your persistent memory, use the memory_updates tag to edit or add information.
        
        Use the execution_status tag to indicate if you've completed the task or need more input from the user.
        """
        
        # Print the full prompt
        print(prompt)
        print("\n=== End Message ===\n")
        
        try:
            # Set a callback to handle streaming in the interface
            def stream_callback(content, is_reasoning=False):
                if is_reasoning:
                    # Use yellow color for reasoning tokens
                    self.console.print(f"[yellow]{content}[/yellow]", end="")
                else:
                    # Use rich for normal content
                    self.console.print(content, end="", highlight=False)
                    
            # Pass the callback to the agent
            self.agent.stream_callback = stream_callback
            response = self.agent.stream_reasoning(prompt)
            
            # Process the response
            self.process_chat_response(response)
                
        except KeyboardInterrupt:
            self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
    
    def _should_continue_execution(self, execution_contexts: List[str]) -> bool:
        """Determine if we should continue execution based on command results"""
        # Parse each execution context to check for success
        for context_xml in execution_contexts:
            try:
                root = ET.fromstring(context_xml)
                success_elem = root.find("./success")
                if success_elem is not None and success_elem.text == "true":
                    # At least one successful command means we should continue
                    return True
            except ET.ParseError:
                continue
        
        # Ask the user if we should continue despite no successful commands
        confirm = Prompt.ask(
            "\nNo commands succeeded. Continue with model execution?", 
            choices=["Y", "n"], 
            default="Y"
        )
        return confirm.lower() == "y"
    
    def execute_file_edit(self, edit_element):
        """Execute a file edit from the XML"""
        try:
            path = edit_element.get("path", "")
            if not path:
                self.console.print("[bold red]Error: Missing file path in edit[/bold red]")
                return False
                
            # Determine syntax highlighting language based on file extension
            language = "python"  # default
            if path:
                ext = os.path.splitext(path)[1].lower()
                if ext in ['.js', '.jsx']:
                    language = "javascript"
                elif ext in ['.html', '.htm']:
                    language = "html"
                elif ext in ['.css']:
                    language = "css"
                elif ext in ['.json']:
                    language = "json"
                elif ext in ['.md']:
                    language = "markdown"
                elif ext in ['.sh']:
                    language = "bash"
                elif ext in ['.yml', '.yaml']:
                    language = "yaml"
            
            # Get search and replace elements
            search_elem = edit_element.find("search")
            replace_elem = edit_element.find("replace")
            
            if search_elem is None or replace_elem is None:
                self.console.print("[bold red]Error: Missing search or replace elements[/bold red]")
                return False
                
            search_text = search_elem.text if search_elem.text else ""
            replace_text = replace_elem.text if replace_elem.text else ""
            
            # Display the edit
            self.console.print(f"[bold cyan]File Edit:[/bold cyan] {path}")
            self.console.print("[bold red]- Search:[/bold red]")
            self.console.print(Syntax(search_text, language, theme="monokai"))
            self.console.print("[bold green]+ Replace:[/bold green]")
            self.console.print(Syntax(replace_text, language, theme="monokai"))
            
            # Ask for confirmation
            confirm = Prompt.ask(
                "\nApply this edit?", 
                choices=["Y", "n"], 
                default="Y"
            )
            
            if confirm.lower() != "y":
                self.console.print("[bold yellow]Edit skipped[/bold yellow]")
                return False
                
            # Check if file exists
            if not os.path.exists(path):
                # Ask if we should create the file
                create_file = Prompt.ask(
                    f"File {path} does not exist. Create it?",
                    choices=["Y", "n"],
                    default="Y"
                )
                
                if create_file.lower() != "y":
                    self.console.print("[bold yellow]Edit skipped[/bold yellow]")
                    return False
                    
                # Create directory if it doesn't exist
                directory = os.path.dirname(path)
                if directory and not os.path.exists(directory):
                    os.makedirs(directory)
                    self.console.print(f"[bold green]Created directory: {directory}[/bold green]")
                
                # Create empty file
                with open(path, 'w') as f:
                    pass
                self.console.print(f"[bold green]Created file: {path}[/bold green]")
                
                # For new files, just write the replace text
                with open(path, 'w') as f:
                    f.write(replace_text)
                self.console.print(f"[bold green]Applied edit to {path}[/bold green]")
                return True
            
            # Read the file content
            with open(path, 'r') as f:
                content = f.read()
                
            # Apply the search and replace
            if search_text == "":
                # Empty search means append to the file
                new_content = content + replace_text
                self.console.print("[bold blue]Appending to file[/bold blue]")
            else:
                # Replace the search text with the replace text
                if search_text not in content:
                    self.console.print(f"[bold yellow]Warning: Search text not found in {path}[/bold yellow]")
                    return False
                    
                new_content = content.replace(search_text, replace_text, 1)
                
            # Write the new content
            with open(path, 'w') as f:
                f.write(new_content)
                
            self.console.print(f"[bold green]Applied edit to {path}[/bold green]")
            return True
            
        except Exception as e:
            self.console.print(f"[bold red]Error executing file edit: {e}[/bold red]")
            return False
    
    def _continue_execution_with_context(self, previous_message_xml: str, execution_contexts: List[str]):
        """Continue execution with the model using command execution context"""
        self.console.print("[bold blue]Continuing execution with command results...[/bold blue]")
        
        # Move cursor to top of terminal and clear scroll buffer
        print("\x1b[3J\x1b[H\x1c2J", end="")
        
        # Extract message content if available
        message_content = ""
        if previous_message_xml:
            try:
                root = ET.fromstring(previous_message_xml)
                message_content = root.text if root.text else ""
            except ET.ParseError:
                message_content = "Error parsing previous message"
        
        # Construct a prompt with execution contexts
        contexts_xml = "\n".join(execution_contexts)
        
        # Get current date, time and timezone for context
        now = datetime.datetime.now()
        timezone = datetime.datetime.now().astimezone().tzinfo
        
        # Print the model being used
        print("\n=== Message Sent to Model ===\n")
        print(f"Model: {self.agent.model_name}")
        
        prompt = f"""
        <context>
          <previous_message>{message_content}</previous_message>
          <command_results>
            {contexts_xml}
          </command_results>
          <system_info>
            <date>{now.strftime('%Y-%m-%d')}</date>
            <time>{now.strftime('%H:%M:%S')}</time>
            <timezone>{timezone}</timezone>
          </system_info>
        </context>
        
        You are continuing a task based on the results of previous commands.
        
        Based on these results, please continue with the task. You can:
        1. Provide additional information or explanation using <message> tags
        2. Suggest new commands to run using <shell_commands> tags
        3. Suggest file modifications using <file_edits> tags
        4. Suggest actions using <actions> tags
        
        Respond using the appropriate XML tags for each part of your response.
        """
        
        # Print the full prompt
        print(prompt)
        print("\n=== End Message ===\n")
        
        # Set a callback to handle streaming in the interface
        def stream_callback(content, is_reasoning=False):
            if is_reasoning:
                # Use yellow color for reasoning tokens
                self.console.print(f"[yellow]{content}[/yellow]", end="")
            else:
                # Use rich for normal content
                self.console.print(content, end="", highlight=False)
                
        # Pass the callback to the agent
        self.agent.stream_callback = stream_callback
        response = self.agent.stream_reasoning(prompt)
        
        # Process the response
        self.process_chat_response(response)
    
    def _format_history_for_prompt(self):
        """Format chat history for inclusion in the prompt"""
        # Limit history to last 10 messages to avoid context overflow
        recent_history = self.chat_history[-10:] if len(self.chat_history) > 10 else self.chat_history
        
        formatted_history = []
        for msg in recent_history[:-1]:  # Exclude the current message which is added separately
            role = msg["role"]
            content = msg["content"]
            timestamp = msg.get("timestamp", "")
            
            # Format as XML
            entry = f"<entry role=\"{role}\" timestamp=\"{timestamp}\">"
            
            # For assistant messages, try to extract just the message part to keep history cleaner
            if role == "assistant":
                message_xml = self.agent.extract_xml_from_response(content, "message")
                if message_xml:
                    try:
                        root = ET.fromstring(message_xml)
                        message_text = root.text if root.text else ""
                        entry += f"<content>{message_text}</content>"
                    except ET.ParseError:
                        entry += f"<content>{content}</content>"
                else:
                    entry += f"<content>{content}</content>"
            else:
                entry += f"<content>{content}</content>"
                
            entry += "</entry>"
            formatted_history.append(entry)
        
        return "\n".join(formatted_history)
    
    def _load_persistent_memory(self):
        """Load memory from file"""
        memory_file = "agent_memory.xml"
        try:
            if os.path.exists(memory_file):
                with open(memory_file, 'r') as f:
                    return f.read()
            else:
                # Create default memory structure - simple and flexible
                default_memory = "<memory>\n  <!-- Agent can structure this as needed -->\n</memory>"
                with open(memory_file, 'w') as f:
                    f.write(default_memory)
                return default_memory
        except Exception as e:
            self.console.print(f"[dim]Could not load memory: {e}[/dim]")
            return "<memory></memory>"
    
    def _update_persistent_memory(self, memory_updates_xml):
        """Update memory based on model's instructions"""
        if not memory_updates_xml:
            return
            
        try:
            memory_file = "agent_memory.xml"
            current_memory = self._load_persistent_memory()
            
            # Parse the updates
            updates_root = ET.fromstring(memory_updates_xml)
            
            # Parse current memory
            try:
                memory_root = ET.fromstring(current_memory)
            except ET.ParseError:
                # If parsing fails, create a new memory structure
                memory_root = ET.Element("memory")
            
            # Process edits - simple search/replace approach
            for edit in updates_root.findall("./edit"):
                search_elem = edit.find("search")
                replace_elem = edit.find("replace")
                
                if search_elem is not None and replace_elem is not None:
                    search_text = search_elem.text if search_elem.text else ""
                    replace_text = replace_elem.text if replace_elem.text else ""
                    
                    # Convert memory to string for search/replace
                    memory_str = ET.tostring(memory_root, encoding='unicode')
                    
                    if search_text in memory_str:
                        # Replace the text
                        memory_str = memory_str.replace(search_text, replace_text)
                        
                        # Parse the updated memory
                        memory_root = ET.fromstring(memory_str)
            
            # Process additions - just add text directly to memory
            for append in updates_root.findall("./append"):
                append_text = append.text if append.text else ""
                if append_text:
                    # Append to existing memory text
                    if memory_root.text is None:
                        memory_root.text = append_text
                    else:
                        memory_root.text += "\n" + append_text
            
            # Save the updated memory
            updated_memory = self.agent.pretty_format_xml(ET.tostring(memory_root, encoding='unicode'))
            with open(memory_file, 'w') as f:
                f.write(updated_memory)
                
            self.console.print("[dim]Memory updated[/dim]")
            
        except Exception as e:
            self.console.print(f"[bold red]Error updating memory: {e}[/bold red]")
    
    def process_chat_response(self, response: str):
        """Process the XML response from the model chat"""
        # Move existing text up and clear remaining space
        terminal_height = self._get_terminal_height()
        # Move cursor up by terminal height and clear from cursor down
        print(f"\x1b[{terminal_height}F\x1b[J", end="")
        
        # Display full XML response
        self.console.print("[bold blue]Full Agent Response XML:[/bold blue]")
        try:
            formatted_xml = self.agent.pretty_format_xml(response)
            self.console.print(Syntax(formatted_xml, "xml", theme="monokai", line_numbers=True))
        except Exception as e:
            self.console.print(f"[red]Error formatting XML: {e}[/red]")
            self.console.print(response)

        # Extract different parts of the response
        message_xml = self.agent.extract_xml_from_response(response, "message")
        actions_xml = self.agent.extract_xml_from_response(response, "actions")
        shell_commands_xml = self.agent.extract_xml_from_response(response, "shell_commands")
        file_edits_xml = self.agent.extract_xml_from_response(response, "file_edits")
        memory_updates_xml = self.agent.extract_xml_from_response(response, "memory_updates")
        execution_status_xml = self.agent.extract_xml_from_response(response, "execution_status")
        
        # Extract only the non-reasoning part for history
        # We don't want to save the reasoning tokens to avoid polluting the context
            
        # Combine the extracted parts for history
        history_content = ""
        for xml_part in [message_xml, actions_xml, shell_commands_xml, file_edits_xml, execution_status_xml]:
            if xml_part:
                history_content += xml_part + "\n"
            
        if not history_content:
            history_content = response  # Fallback to full response if extraction failed
            
        # Add response to history
        timestamp = datetime.datetime.now().isoformat()
        self.chat_history.append({
            "role": "assistant",
            "content": history_content,
            "timestamp": timestamp
        })
            
        # Save updated history
        self.save_chat_history()
        
        # Process memory updates if present
        if memory_updates_xml:
            self._update_persistent_memory(memory_updates_xml)
        
        # Process message if present
        if message_xml:
            try:
                # Parse the XML to get just the text content
                root = ET.fromstring(message_xml)
                message_text = root.text if root.text else ""
                
                # Display the message as markdown
                self.console.print("")
                self.console.print(Markdown(message_text))
                self.console.print("")
            except ET.ParseError:
                # Fallback if parsing fails
                self.console.print(f"\n{message_xml}\n")
        
        # Process actions if present
        if actions_xml:
            try:
                actions_root = ET.fromstring(actions_xml)
                actions = actions_root.findall("./action")
                
                if actions:
                    self.console.print("[bold blue]The model suggests the following actions:[/bold blue]")
                    
                    for action in actions:
                        self.execute_action(action)
                        
            except ET.ParseError as e:
                self.console.print(f"[bold red]Error parsing actions XML: {e}[/bold red]")
        
        # Process file edits if present
        if file_edits_xml:
            try:
                edits_root = ET.fromstring(file_edits_xml)
                edits = edits_root.findall("./edit")
                
                if edits:
                    self.console.print("[bold blue]The model suggests the following file edits:[/bold blue]")
                    
                    for edit in edits:
                        self.execute_file_edit(edit)
                        
            except ET.ParseError as e:
                self.console.print(f"[bold red]Error parsing file edits XML: {e}[/bold red]")
        
        # Process shell commands if present
        if shell_commands_xml:
            try:
                commands_root = ET.fromstring(shell_commands_xml)
                commands = commands_root.findall("./command")
                
                execution_contexts = []
                
                if commands:
                    self.console.print("[bold blue]The model suggests the following shell commands:[/bold blue]")
                    
                    for cmd_elem in commands:
                        command = cmd_elem.text.strip() if cmd_elem.text else ""
                        auto_run = cmd_elem.get("safe_to_autorun", "false").lower() == "true"
                        
                        if auto_run:
                            self.console.print(f"[bold green]Auto-running safe command:[/bold green] {command}")
                            success, context_xml = self.execute_shell_command(command, auto_run=True)
                        else:
                            success, context_xml = self.execute_shell_command(command, auto_run=False)
                        
                        execution_contexts.append(context_xml)
                
                # If there are execution contexts and we need to continue with the model
                if execution_contexts and self._should_continue_execution(execution_contexts):
                    self._continue_execution_with_context(message_xml, execution_contexts)
                        
            except ET.ParseError as e:
                self.console.print(f"[bold red]Error parsing shell commands XML: {e}[/bold red]")
        
        # Process execution status if present
        if execution_status_xml:
            try:
                status_root = ET.fromstring(execution_status_xml)
                complete = status_root.get("complete", "false").lower() == "true"
                needs_input = status_root.get("needs_user_input", "false").lower() == "true"
                
                status_message = ""
                message_elem = status_root.find("./message")
                if message_elem is not None and message_elem.text:
                    status_message = message_elem.text
                
                if complete:
                    self.console.print("[bold green]✓ Task completed[/bold green]")
                    if status_message:
                        self.console.print(f"[green]{status_message}[/green]")
                elif needs_input:
                    self.console.print("[bold yellow]⚠ Waiting for user input[/bold yellow]")
                    if status_message:
                        self.console.print(f"[yellow]{status_message}[/yellow]")
                else:
                    self.console.print("[bold blue]⟳ Task in progress[/bold blue]")
                    if status_message:
                        self.console.print(f"[blue]{status_message}[/blue]")
                
            except ET.ParseError as e:
                self.console.print(f"[bold red]Error parsing execution status XML: {e}[/bold red]")
    
    def run_interactive(self):
        """Run the interface in interactive mode"""
        self.display_welcome()
        
        while True:
            try:
                # Handle multiline input mode
                if self.multiline_input_mode:
                    user_input = Prompt.ask("\n[bold yellow]paste>[/bold yellow]")
                    
                    # Check for end of multiline input
                    if user_input.lower() in ["/end", "/done", "/finish"]:
                        self.multiline_input_mode = False
                        
                        # Process the collected input
                        if self.multiline_input_buffer:
                            full_input = "\n".join(self.multiline_input_buffer)
                            self.console.print(f"[dim]Processing {len(self.multiline_input_buffer)} lines of input...[/dim]")
                            self.chat_with_model(full_input)
                            self.multiline_input_buffer = []
                        else:
                            self.console.print("[yellow]No input to process[/yellow]")
                    else:
                        # Add to buffer
                        self.multiline_input_buffer.append(user_input)
                        self.console.print(f"[dim]Line {len(self.multiline_input_buffer)} added[/dim]")
                else:
                    # Normal single-line input mode
                    user_input = Prompt.ask("\n[bold blue]>[/bold blue]")
                    
                    if user_input.lower() in ["exit", "quit", "q", "/exit", "/quit", "/q"]:
                        self.console.print("[bold blue]Exiting...[/bold blue]")
                        sys.exit(0)
                    
                    # Check if this is a paste command
                    if user_input.lower() == "/paste":
                        self.multiline_input_mode = True
                        self.multiline_input_buffer = []
                        self.console.print("[bold yellow]Entering multiline paste mode. Type /end when finished.[/bold yellow]")
                        continue
                    
                    # Check if this is a slash command
                    if user_input.startswith('/'):
                        # Remove the slash and split into command parts
                        command = user_input[1:].strip().split()
                        self.run_command(command)
                    else:
                        # Check if this might be a multiline paste
                        if "\n" in user_input:
                            lines = user_input.split("\n")
                            self.console.print(f"[dim]Detected multiline paste with {len(lines)} lines[/dim]")
                            self.chat_with_model(user_input)
                        else:
                            # Treat as direct chat with the model
                            self.chat_with_model(user_input)
                    
            except KeyboardInterrupt:
                if self.multiline_input_mode:
                    self.console.print("\n[bold yellow]Cancelling multiline input[/bold yellow]")
                    self.multiline_input_mode = False
                    self.multiline_input_buffer = []
                else:
                    self.console.print("\n[bold yellow]Exiting...[/bold yellow]")
                    sys.exit(0)
            except EOFError:  # Handle Ctrl+D
                self.console.print("\n[bold yellow]Exiting...[/bold yellow]")
                sys.exit(0)
            except Exception as e:
                self.console.print(f"[bold red]Error:[/bold red] {e}")

def main():
    """Main function to run the agent interface"""
    interface = AgentInterface()
    interface.run_interactive()

if __name__ == "__main__":
    main()
