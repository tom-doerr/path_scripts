#!/usr/bin/env python3

import os
import sys
import subprocess
from typing import List, Optional
import xml.etree.ElementTree as ET
from rich.console import Console
from rich.panel import Panel
from rich.tree import Tree
from rich.syntax import Syntax
from rich.prompt import Prompt
from rich.markdown import Markdown

# Import the Agent class from the agent script
# Use a local import with the full path to avoid package conflicts
import os
import sys
# Get the directory of the current script
current_dir = os.path.dirname(os.path.abspath(__file__))
# Add the parent directory to the path to find the agent module
sys.path.insert(0, current_dir)
# Now import the Agent class
from agent import Agent

class AgentInterface:
    def __init__(self):
        self.console = Console()
        self.agent = Agent()
        self.current_plan = None
    
    def display_welcome(self):
        """Display welcome message and instructions"""
        self.console.print(Panel.fit(
            "[bold blue]Agent Interface[/bold blue]\n"
            "A simple interface for the agent planning system\n"
            "Type [bold]help[/bold] for available commands",
            title="Welcome",
            border_style="blue"
        ))
    
    def display_help(self):
        """Display available commands"""
        help_text = """
        [bold]Available Commands:[/bold]
        
        [bold green]init[/bold green] - Initialize the agent
        [bold green]plan <spec_file>[/bold green] - Generate a plan from specification
        [bold green]display[/bold green] - Display the current plan
        [bold green]update <task_id> <status> [--notes=text] [--progress=0-100][/bold green] - Update task status
        [bold green]execute <task_id>[/bold green] - Execute a specific task (with confirmation)
        [bold green]model <model_name>[/bold green] - Change the model
        [bold green]help[/bold green] - Show this help
        [bold green]exit[/bold green] - Exit the interface
        """
        self.console.print(Markdown(help_text))
    
    def execute_action(self, action_element):
        """Execute a single action from the XML"""
        try:
            action_type = action_element.get("type", "unknown")
            path = action_element.get("path", "")
            command = action_element.get("command", "")
            
            if action_type == "create_file":
                # Create the file with the content
                content = action_element.text.strip() if action_element.text else ""
                
                # Create directory if it doesn't exist
                directory = os.path.dirname(path)
                if directory and not os.path.exists(directory):
                    os.makedirs(directory)
                    self.console.print(f"[bold green]Created directory: {directory}[/bold green]")
                
                with open(path, 'w') as f:
                    f.write(content)
                self.console.print(f"[bold green]Created file: {path}[/bold green]")
                
                # Make executable if it's a script
                if path.endswith('.py') or not os.path.splitext(path)[1]:
                    os.chmod(path, 0o755)
                    self.console.print(f"[bold green]Made file executable: {path}[/bold green]")
                
            elif action_type == "modify_file":
                if not os.path.exists(path):
                    self.console.print(f"[bold red]Error: File {path} does not exist[/bold red]")
                    return
                
                # Read the original file
                with open(path, 'r') as f:
                    file_content = f.read()
                
                # Apply each change
                for change in action_element.findall("./change"):
                    original = change.find("original").text if change.find("original") is not None else ""
                    new = change.find("new").text if change.find("new") is not None else ""
                    
                    if original in file_content:
                        file_content = file_content.replace(original, new)
                        self.console.print(f"[bold green]Modified file: {path}[/bold green]")
                    else:
                        self.console.print(f"[bold yellow]Warning: Could not find text to replace in {path}[/bold yellow]")
                
                # Write the modified content back
                with open(path, 'w') as f:
                    f.write(file_content)
                
            elif action_type == "run_command":
                self.console.print(f"[bold blue]Running command: {command}[/bold blue]")
                
                # Run the command and capture output
                process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                
                # Stream output in real-time
                for line in process.stdout:
                    self.console.print(line.rstrip())
                
                # Wait for process to complete
                process.wait()
                
                if process.returncode == 0:
                    self.console.print(f"[bold green]Command completed successfully[/bold green]")
                else:
                    stderr = process.stderr.read()
                    self.console.print(f"[bold red]Command failed with exit code {process.returncode}[/bold red]")
                    if stderr:
                        self.console.print(f"[bold red]Error: {stderr}[/bold red]")
            
            else:
                self.console.print(f"[bold yellow]Unknown action type: {action_type}[/bold yellow]")
                
        except Exception as e:
            self.console.print(f"[bold red]Error executing action: {e}[/bold red]")
    
    def display_plan_tree(self, xml_content: str):
        """Display the plan as a rich tree"""
        try:
            # Parse the XML
            root = ET.fromstring(xml_content)
            plan_element = root.find(".//plan")
            
            if plan_element is None:
                self.console.print("[bold red]Error:[/bold red] No plan found in XML")
                return
            
            # Create a rich tree
            tree = Tree("[bold blue]Plan[/bold blue]")
            
            # Process tasks recursively
            def add_tasks(parent_element, parent_tree):
                for task in parent_element.findall("./task"):
                    task_id = task.get("id", "unknown")
                    description = task.get("description", "No description")
                    status = task.get("status", "pending")
                    complexity = task.get("complexity", "unknown")
                    
                    # Choose color based on status
                    status_color = {
                        "pending": "yellow",
                        "in-progress": "blue",
                        "completed": "green",
                        "failed": "red"
                    }.get(status, "white")
                    
                    # Get dependencies and progress
                    depends_on = task.get("depends_on", "")
                    progress = task.get("progress", "0")
                    
                    # Create task node
                    task_text = f"[bold]{task_id}[/bold]: {description} "
                    task_text += f"[{status_color}]({status})[/{status_color}]"
                    
                    # Add progress bar if available
                    if progress and progress.isdigit():
                        progress_int = int(progress)
                        progress_bar = "█" * (progress_int // 10) + "░" * (10 - (progress_int // 10))
                        task_text += f" [{status_color}]{progress_bar} {progress}%[/{status_color}]"
                    
                    task_text += f" [dim]complexity: {complexity}[/dim]"
                    
                    # Add dependencies if present
                    if depends_on:
                        task_text += f" [dim italic]depends on: {depends_on}[/dim italic]"
                    
                    task_node = parent_tree.add(task_text)
                    
                    # Add notes if present
                    notes = task.get("notes")
                    if notes:
                        task_node.add(f"[italic dim]Notes: {notes}[/italic dim]")
                    
                    # Process subtasks
                    add_tasks(task, task_node)
            
            # Start with the root task
            root_task = plan_element.find("./task")
            if root_task is not None:
                add_tasks(plan_element, tree)
            
            # Display the tree
            self.console.print(tree)
            
        except ET.ParseError as e:
            self.console.print(f"[bold red]Error parsing XML:[/bold red] {e}")
        except Exception as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")
    
    def run_command(self, command: List[str]):
        """Run a command and handle the result"""
        if not command:
            return
        
        cmd = command[0].lower()
        args = command[1:]
        
        if cmd == "help":
            self.display_help()
        
        elif cmd == "exit":
            self.console.print("[bold blue]Exiting...[/bold blue]")
            sys.exit(0)
        
        elif cmd == "init":
            with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                self.agent.initialize()
            self.console.print("[bold green]Agent initialized successfully[/bold green]")
        
        elif cmd == "model":
            if not args:
                self.console.print(f"[bold blue]Current model:[/bold blue] {self.agent.model_name}")
                return
                
            model_name = args[0]
            self.agent.model_name = model_name
            
            # Handle special case for r1
            if model_name == "r1":
                self.agent.model_name = "deepseek/deepseek-reasoner"
                
            self.console.print(f"[bold green]Model changed to:[/bold green] {self.agent.model_name}")
        
        elif cmd == "plan":
            if not args:
                self.console.print("[bold red]Error:[/bold red] Missing specification file")
                return
            
            spec_file = args[0]
            try:
                with open(spec_file, 'r') as f:
                    spec = f.read()
                
                self.console.print(f"[bold blue]Using model:[/bold blue] {self.agent.model_name}")
                
                # Initialize if not already done
                if not self.agent.repository_info:
                    with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                        self.agent.initialize()
                
                # Generate plan
                with self.console.status("[bold blue]Generating plan...[/bold blue]"):
                    try:
                        result = self.agent.generate_plan(spec)
                        
                        # Save the plan to a file
                        with open("agent_plan.xml", 'w') as f:
                            f.write(result)
                        
                        # Extract plan XML for display
                        plan_xml = self.agent.extract_xml_from_response(result, "plan")
                        if plan_xml:
                            self.current_plan = plan_xml
                            self.display_plan_tree(result)
                        else:
                            self.console.print("[bold red]Error:[/bold red] No plan found in response")
                            
                        self.console.print("[bold green]Plan saved to agent_plan.xml[/bold green]")
                        
                    except KeyboardInterrupt:
                        self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
                
            except FileNotFoundError:
                self.console.print(f"[bold red]Error:[/bold red] Specification file '{spec_file}' not found")
        
        elif cmd == "display":
            # Load the plan from file if not already loaded
            if not self.current_plan:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                        self.current_plan = xml_content
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            self.display_plan_tree(self.current_plan)
        
        elif cmd == "update":
            if len(args) < 2:
                self.console.print("[bold red]Error:[/bold red] Missing task_id or status")
                return
            
            task_id = args[0]
            status = args[1]
            
            # Check for progress and notes flags
            progress = None
            notes = None
            
            for i, arg in enumerate(args[2:], 2):
                if arg.startswith("--progress="):
                    progress = arg.split("=")[1]
                elif arg.startswith("--notes="):
                    notes = arg.split("=")[1]
                elif i == 2 and not arg.startswith("--"):
                    # For backward compatibility, treat the third argument as notes
                    notes = arg
            
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            with self.console.status(f"[bold blue]Updating task {task_id}...[/bold blue]"):
                result = self.agent.update_plan(task_id, status, notes, progress)
            
            # Save the updated plan
            with open("agent_plan.xml", 'w') as f:
                f.write(result)
            
            self.current_plan = result
            self.console.print(f"[bold green]Task {task_id} updated to {status}[/bold green]")
            self.display_plan_tree(result)
        
        elif cmd == "execute":
            if not args:
                self.console.print("[bold red]Error:[/bold red] Missing task_id")
                return
            
            task_id = args[0]
            
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            self.console.print(f"[bold blue]Executing task {task_id}...[/bold blue]")
            
            try:
                result = self.agent.execute_task(task_id)
                
                # Save the actions to a file
                with open(f"agent_actions_{task_id}.xml", 'w') as f:
                    f.write(result)
                
                # Save the updated plan
                with open("agent_plan.xml", 'w') as f:
                    f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                
                # Display the actions
                actions_xml = self.agent.extract_xml_from_response(result, "actions")
                if actions_xml:
                    syntax = Syntax(actions_xml, "xml", theme="monokai", line_numbers=True)
                    self.console.print(Panel(syntax, title=f"Actions for Task {task_id}", border_style="green"))
                    
                    # Parse the actions to show them individually for confirmation
                    try:
                        actions_root = ET.fromstring(actions_xml)
                        for i, action in enumerate(actions_root.findall("./action")):
                            action_type = action.get("type", "unknown")
                            path = action.get("path", "")
                            command = action.get("command", "")
                            
                            if action_type == "create_file":
                                self.console.print(f"\n[bold cyan]Action {i+1}:[/bold cyan] Create file '{path}'")
                                content = action.text.strip() if action.text else ""
                                self.console.print(Syntax(content, "python", theme="monokai"))
                                
                            elif action_type == "modify_file":
                                self.console.print(f"\n[bold cyan]Action {i+1}:[/bold cyan] Modify file '{path}'")
                                for change in action.findall("./change"):
                                    original = change.find("original").text if change.find("original") is not None else ""
                                    new = change.find("new").text if change.find("new") is not None else ""
                                    self.console.print("[bold red]- Original:[/bold red]")
                                    self.console.print(Syntax(original, "python", theme="monokai"))
                                    self.console.print("[bold green]+ New:[/bold green]")
                                    self.console.print(Syntax(new, "python", theme="monokai"))
                                    
                            elif action_type == "run_command":
                                self.console.print(f"\n[bold cyan]Action {i+1}:[/bold cyan] Run command '{command}'")
                            
                            # Ask for confirmation for each action
                            confirm = Prompt.ask(
                                "\nExecute this action?", 
                                choices=["y", "n", "all", "none"], 
                                default="n"
                            )
                            
                            if confirm.lower() == "none":
                                self.console.print("[bold yellow]Skipping all remaining actions[/bold yellow]")
                                break
                            elif confirm.lower() == "all":
                                self.console.print("[bold green]Executing all remaining actions[/bold green]")
                                # Execute this and all remaining actions
                                execute_all = True
                                self.execute_action(action)
                                for remaining_action in list(actions_root.findall("./action"))[i+1:]:
                                    self.execute_action(remaining_action)
                                break
                            elif confirm.lower() == "y":
                                self.console.print("[bold green]Executing action...[/bold green]")
                                self.execute_action(action)
                            else:
                                self.console.print("[bold yellow]Action skipped[/bold yellow]")
                    
                    except ET.ParseError:
                        self.console.print("[bold red]Error parsing actions XML[/bold red]")
                
                self.console.print(f"[bold green]Actions saved to agent_actions_{task_id}.xml[/bold green]")
                
            except KeyboardInterrupt:
                self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
        
        else:
            self.console.print(f"[bold red]Unknown command:[/bold red] {cmd}")
            self.console.print("Type [bold]help[/bold] for available commands")
    
    def run_interactive(self):
        """Run the interface in interactive mode"""
        self.display_welcome()
        
        while True:
            try:
                user_input = Prompt.ask("\n[bold blue]>[/bold blue]")
                command = user_input.strip().split()
                self.run_command(command)
            except KeyboardInterrupt:
                self.console.print("\n[bold yellow]Use 'exit' to quit[/bold yellow]")
            except Exception as e:
                self.console.print(f"[bold red]Error:[/bold red] {e}")

def main():
    """Main function to run the agent interface"""
    interface = AgentInterface()
    interface.run_interactive()

if __name__ == "__main__":
    main()
