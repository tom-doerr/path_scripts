#!/usr/bin/env python3
# Make sure this file is executable with: chmod +x agent_interface

import os
import sys
import subprocess
from typing import List, Optional
import xml.etree.ElementTree as ET
from rich.console import Console
from rich.panel import Panel
from rich.tree import Tree
from rich.syntax import Syntax
from rich.prompt import Prompt
from rich.markdown import Markdown

# Import the Agent class directly
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)
from agent import Agent

class AgentInterface:
    def __init__(self):
        self.console = Console()
        self.agent = Agent()
        self.current_plan = None
    
    def display_welcome(self):
        """Display welcome message and instructions"""
        self.console.print(Panel.fit(
            "[bold blue]Agent Interface[/bold blue]\n"
            "A simple interface for the agent planning system\n"
            "Type [bold]help[/bold] for available commands",
            title="Welcome",
            border_style="blue"
        ))
    
    def display_help(self):
        """Display available commands"""
        self.console.print("[bold]Available Commands:[/bold]")
        self.console.print("")
        self.console.print("[bold green]init[/bold green]", "- Initialize the agent")
        self.console.print("[bold green]plan [spec_file][/bold green]", "- Generate a plan from specification (default: spec.md)")
        self.console.print("[bold green]display[/bold green]", "- Display the current plan")
        self.console.print("[bold green]update <task_id> <status> [--notes=text] [--progress=0-100][/bold green]", "- Update task status")
        self.console.print("[bold green]execute <task_id>[/bold green]", "- Execute a specific task (with confirmation)")
        self.console.print("[bold green]model <model_name>[/bold green]", "- Change the model")
        self.console.print("[bold green]help[/bold green]", "- Show this help")
        self.console.print("[bold green]exit[/bold green]", "- Exit the interface")
    
    def execute_action(self, action_element):
        """Execute a single action from the XML"""
        try:
            action_type = action_element.get("type", "unknown")
            path = action_element.get("path", "")
            command = action_element.get("command", "")
            
            # Ask for confirmation before executing
            if action_type == "create_file":
                content = action_element.text.strip() if action_element.text else ""
                self.console.print(f"[bold cyan]Action:[/bold cyan] Create file '{path}'")
                self.console.print(Syntax(content, "python", theme="monokai"))
                
            elif action_type == "modify_file":
                self.console.print(f"[bold cyan]Action:[/bold cyan] Modify file '{path}'")
                for change in action_element.findall("./change"):
                    original = change.find("original").text if change.find("original") is not None else ""
                    new = change.find("new").text if change.find("new") is not None else ""
                    self.console.print("[bold red]- Original:[/bold red]")
                    self.console.print(Syntax(original, "python", theme="monokai"))
                    self.console.print("[bold green]+ New:[/bold green]")
                    self.console.print(Syntax(new, "python", theme="monokai"))
                    
            elif action_type == "run_command":
                self.console.print(f"[bold cyan]Action:[/bold cyan] Run command '{command}'")
            
            # Ask for confirmation
            confirm = Prompt.ask(
                "\nExecute this action?", 
                choices=["y", "n"], 
                default="n"
            )
            
            if confirm.lower() != "y":
                self.console.print("[bold yellow]Action skipped[/bold yellow]")
                return False
            
            # Execute the action
            if action_type == "create_file":
                # Create the file with the content
                content = action_element.text.strip() if action_element.text else ""
                
                # Create directory if it doesn't exist
                directory = os.path.dirname(path)
                if directory and not os.path.exists(directory):
                    os.makedirs(directory)
                    self.console.print(f"[bold green]Created directory: {directory}[/bold green]")
                
                with open(path, 'w') as f:
                    f.write(content)
                self.console.print(f"[bold green]Created file: {path}[/bold green]")
                
                # Make executable if it's a script
                if path.endswith('.py') or not os.path.splitext(path)[1]:
                    os.chmod(path, 0o755)
                    self.console.print(f"[bold green]Made file executable: {path}[/bold green]")
                
                return True
                
            elif action_type == "modify_file":
                if not os.path.exists(path):
                    self.console.print(f"[bold red]Error: File {path} does not exist[/bold red]")
                    return False
                
                # Read the original file
                with open(path, 'r') as f:
                    file_content = f.read()
                
                # Apply each change
                changes_applied = False
                for change in action_element.findall("./change"):
                    original = change.find("original").text if change.find("original") is not None else ""
                    new = change.find("new").text if change.find("new") is not None else ""
                    
                    if original in file_content:
                        file_content = file_content.replace(original, new)
                        changes_applied = True
                    else:
                        self.console.print(f"[bold yellow]Warning: Could not find text to replace in {path}[/bold yellow]")
                
                # Write the modified content back
                if changes_applied:
                    with open(path, 'w') as f:
                        f.write(file_content)
                    self.console.print(f"[bold green]Modified file: {path}[/bold green]")
                    return True
                else:
                    self.console.print(f"[bold yellow]No changes applied to {path}[/bold yellow]")
                    return False
                
            elif action_type == "run_command":
                self.console.print(f"[bold blue]Running command: {command}[/bold blue]")
                
                # Run the command and capture output
                process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                
                # Stream output in real-time
                for line in process.stdout:
                    self.console.print(line.rstrip())
                
                # Wait for process to complete
                process.wait()
                
                if process.returncode == 0:
                    self.console.print(f"[bold green]Command completed successfully[/bold green]")
                    return True
                else:
                    stderr = process.stderr.read()
                    self.console.print(f"[bold red]Command failed with exit code {process.returncode}[/bold red]")
                    if stderr:
                        self.console.print(f"[bold red]Error: {stderr}[/bold red]")
                    return False
            
            else:
                self.console.print(f"[bold yellow]Unknown action type: {action_type}[/bold yellow]")
                return False
                
        except Exception as e:
            self.console.print(f"[bold red]Error executing action: {e}[/bold red]")
            return False
    
    def display_plan_tree(self, xml_content: str):
        """Display the plan as a rich tree"""
        try:
            # Parse the XML
            root = ET.fromstring(xml_content)
            plan_element = root.find(".//plan")
            
            if plan_element is None:
                self.console.print("[bold red]Error:[/bold red] No plan found in XML")
                return
            
            # Create a rich tree
            tree = Tree("[bold blue]Plan[/bold blue]")
            
            # Process tasks recursively
            def add_tasks(parent_element, parent_tree):
                for task in parent_element.findall("./task"):
                    task_id = task.get("id", "unknown")
                    description = task.get("description", "No description")
                    status = task.get("status", "pending")
                    complexity = task.get("complexity", "unknown")
                    
                    # Choose color based on status
                    status_color = {
                        "pending": "yellow",
                        "in-progress": "blue",
                        "completed": "green",
                        "failed": "red"
                    }.get(status, "white")
                    
                    # Get dependencies and progress
                    depends_on = task.get("depends_on", "")
                    progress = task.get("progress", "0")
                    
                    # Create task node
                    task_text = f"[bold]{task_id}[/bold]: {description} "
                    task_text += f"[{status_color}]({status})[/{status_color}]"
                    
                    # Add progress bar if available
                    if progress and progress.isdigit():
                        progress_int = int(progress)
                        progress_bar = "█" * (progress_int // 10) + "░" * (10 - (progress_int // 10))
                        task_text += f" [{status_color}]{progress_bar} {progress}%[/{status_color}]"
                    
                    task_text += f" [dim]complexity: {complexity}[/dim]"
                    
                    # Add dependencies if present
                    if depends_on:
                        task_text += f" [dim italic]depends on: {depends_on}[/dim italic]"
                    
                    task_node = parent_tree.add(task_text)
                    
                    # Add notes if present
                    notes = task.get("notes")
                    if notes:
                        task_node.add(f"[italic dim]Notes: {notes}[/italic dim]")
                    
                    # Process subtasks
                    add_tasks(task, task_node)
            
            # Start with the root task
            root_task = plan_element.find("./task")
            if root_task is not None:
                add_tasks(plan_element, tree)
            
            # Display the tree
            self.console.print(tree)
            
        except ET.ParseError as e:
            self.console.print(f"[bold red]Error parsing XML:[/bold red] {e}")
        except Exception as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")
    
    def run_command(self, command: List[str]):
        """Run a command and handle the result"""
        if not command:
            return
        
        cmd = command[0].lower()
        args = command[1:]
        
        if cmd == "help":
            self.display_help()
        
        elif cmd == "exit":
            self.console.print("[bold blue]Exiting...[/bold blue]")
            sys.exit(0)
        
        elif cmd == "init":
            with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                self.agent.initialize()
            self.console.print("[bold green]Agent initialized successfully[/bold green]")
        
        elif cmd == "model":
            if not args:
                self.console.print(f"[bold blue]Current model:[/bold blue] {self.agent.model_name}")
                return
                
            model_name = args[0]
            self.agent.model_name = model_name
            
            # Handle special case for r1
            if model_name == "r1":
                self.agent.model_name = "deepseek/deepseek-reasoner"
                
            self.console.print(f"[bold green]Model changed to:[/bold green] {self.agent.model_name}")
        
        elif cmd == "plan":
            # Use spec.md by default if no file specified
            spec_file = args[0] if args else "spec.md"
            self.console.print(f"[bold blue]Using specification file:[/bold blue] {spec_file}")
            try:
                with open(spec_file, 'r') as f:
                    spec = f.read()
                
                self.console.print(f"[bold blue]Using model:[/bold blue] {self.agent.model_name}")
                
                # Initialize if not already done
                if not self.agent.repository_info:
                    with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                        self.agent.initialize()
                
                # Generate plan - don't use status context manager to allow streaming
                self.console.print("[bold blue]Generating plan...[/bold blue]")
                try:
                    # Set a callback to handle streaming in the interface
                    def stream_callback(content, is_reasoning=False):
                        if is_reasoning:
                            self.console.print(f"[yellow]{content}[/yellow]", end="")
                        else:
                            self.console.print(content, end="")
                            
                    # Pass the callback to the agent
                    self.agent.stream_callback = stream_callback
                    result = self.agent.generate_plan(spec)
                            
                    # Save the plan to a file
                    with open("agent_plan.xml", 'w') as f:
                        f.write(result)
                            
                    # Extract plan XML for display
                    plan_xml = self.agent.extract_xml_from_response(result, "plan")
                    if plan_xml:
                        self.current_plan = plan_xml
                        self.console.print("\n\n[bold blue]Generated Plan:[/bold blue]")
                        self.display_plan_tree(result)
                    else:
                        self.console.print("[bold red]Error:[/bold red] No plan found in response")
                                
                    self.console.print("[bold green]Plan saved to agent_plan.xml[/bold green]")
                            
                except KeyboardInterrupt:
                    self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
                
            except FileNotFoundError:
                self.console.print(f"[bold red]Error:[/bold red] Specification file '{spec_file}' not found")
        
        elif cmd == "display":
            # Load the plan from file if not already loaded
            if not self.current_plan:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                        self.current_plan = xml_content
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            self.display_plan_tree(self.current_plan)
        
        elif cmd == "update":
            if len(args) < 2:
                self.console.print("[bold red]Error:[/bold red] Missing task_id or status")
                return
            
            task_id = args[0]
            status = args[1]
            
            # Check for progress and notes flags
            progress = None
            notes = None
            
            for i, arg in enumerate(args[2:], 2):
                if arg.startswith("--progress="):
                    progress = arg.split("=")[1]
                elif arg.startswith("--notes="):
                    notes = arg.split("=")[1]
                elif i == 2 and not arg.startswith("--"):
                    # For backward compatibility, treat the third argument as notes
                    notes = arg
            
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            with self.console.status(f"[bold blue]Updating task {task_id}...[/bold blue]"):
                result = self.agent.update_plan(task_id, status, notes, progress)
            
            # Save the updated plan
            with open("agent_plan.xml", 'w') as f:
                f.write(result)
            
            self.current_plan = result
            self.console.print(f"[bold green]Task {task_id} updated to {status}[/bold green]")
            self.display_plan_tree(result)
        
        elif cmd == "execute":
            if not args:
                self.console.print("[bold red]Error:[/bold red] Missing task_id")
                return
            
            task_id = args[0]
            
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            # Check dependencies first
            deps_met, missing_deps = self.agent.check_dependencies(task_id)
            if not deps_met:
                self.console.print("[bold red]Error:[/bold red] Dependencies not met")
                for dep in missing_deps:
                    self.console.print(f"[bold yellow]- {dep}[/bold yellow]")
                
                confirm = Prompt.ask(
                    "\nContinue anyway?", 
                    choices=["y", "n"], 
                    default="n"
                )
                if confirm.lower() != "y":
                    self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                    return
            
            self.console.print(f"[bold blue]Executing task {task_id}...[/bold blue]")
            
            try:
                result = self.agent.execute_task(task_id)
                
                # Check for errors
                error_element = ET.fromstring(result).find(".//error")
                if error_element is not None and error_element.text:
                    self.console.print(f"[bold red]Error:[/bold red] {error_element.text}")
                    return
                
                # Save the actions to a file
                with open(f"agent_actions_{task_id}.xml", 'w') as f:
                    f.write(result)
                
                # Save the updated plan
                with open("agent_plan.xml", 'w') as f:
                    f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                
                # Display the actions
                actions_xml = self.agent.extract_xml_from_response(result, "actions")
                if actions_xml:
                    # Clean up XML for display
                    try:
                        root = ET.fromstring(actions_xml)
                        clean_xml = ET.tostring(root, encoding='unicode')
                        syntax = Syntax(clean_xml, "xml", theme="monokai", line_numbers=True)
                        self.console.print(Panel(syntax, title=f"Actions for Task {task_id}", border_style="green"))
                    except ET.ParseError:
                        # Fallback if XML parsing fails
                        syntax = Syntax(actions_xml, "xml", theme="monokai", line_numbers=True)
                        self.console.print(Panel(syntax, title=f"Actions for Task {task_id}", border_style="green"))
                    
                    # Parse the actions to show them individually for confirmation
                    try:
                        actions_root = ET.fromstring(actions_xml)
                        actions_count = len(actions_root.findall("./action"))
                        successful_actions = 0
                        
                        for i, action in enumerate(actions_root.findall("./action")):
                            self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                            
                            # Execute the action with confirmation
                            if self.execute_action(action):
                                successful_actions += 1
                        
                        # Update task progress based on completed actions
                        if actions_count > 0:
                            completion_percentage = int((successful_actions / actions_count) * 30) + 70
                            if successful_actions == actions_count:
                                # All actions completed successfully
                                self.console.print("[bold green]All actions completed successfully[/bold green]")
                                
                                # Parse the plan tree
                                root = ET.fromstring(self.agent.plan_tree)
                                task_element = root.find(f".//task[@id='{task_id}']")
                                if task_element is not None:
                                    task_element.set("status", "completed")
                                    task_element.set("progress", "100")
                                    self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                    
                                    # Save the updated plan
                                    with open("agent_plan.xml", 'w') as f:
                                        f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                    
                                    self.console.print(f"[bold green]Task {task_id} marked as completed[/bold green]")
                            else:
                                # Some actions failed
                                self.console.print(f"[bold yellow]{successful_actions}/{actions_count} actions completed[/bold yellow]")
                                
                                # Parse the plan tree
                                root = ET.fromstring(self.agent.plan_tree)
                                task_element = root.find(f".//task[@id='{task_id}']")
                                if task_element is not None:
                                    task_element.set("progress", str(completion_percentage))
                                    self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                    
                                    # Save the updated plan
                                    with open("agent_plan.xml", 'w') as f:
                                        f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                    
                                    self.console.print(f"[bold yellow]Task {task_id} progress updated to {completion_percentage}%[/bold yellow]")
                    
                    except ET.ParseError:
                        self.console.print("[bold red]Error parsing actions XML[/bold red]")
                
                self.console.print(f"[bold green]Actions saved to agent_actions_{task_id}.xml[/bold green]")
                
            except KeyboardInterrupt:
                self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
        
        else:
            self.console.print(f"[bold red]Unknown command:[/bold red] {cmd}")
            self.console.print("Type [bold]help[/bold] for available commands")
    
    def run_interactive(self):
        """Run the interface in interactive mode"""
        self.display_welcome()
        
        while True:
            try:
                user_input = Prompt.ask("\n[bold blue]>[/bold blue]")
                if user_input.lower() in ["exit", "quit", "q"]:
                    self.console.print("[bold blue]Exiting...[/bold blue]")
                    sys.exit(0)
                command = user_input.strip().split()
                self.run_command(command)
            except KeyboardInterrupt:
                self.console.print("\n[bold yellow]Exiting...[/bold yellow]")
                sys.exit(0)
            except EOFError:  # Handle Ctrl+D
                self.console.print("\n[bold yellow]Exiting...[/bold yellow]")
                sys.exit(0)
            except Exception as e:
                self.console.print(f"[bold red]Error:[/bold red] {e}")

def main():
    """Main function to run the agent interface"""
    interface = AgentInterface()
    interface.run_interactive()

if __name__ == "__main__":
    main()
