#!/usr/bin/env python3
# Make sure this file is executable with: chmod +x agent_interface

import os
import sys
import json
import datetime
import subprocess
from typing import List, Optional
import xml.etree.ElementTree as ET
from rich.console import Console
from rich.panel import Panel
from rich.tree import Tree
from rich.syntax import Syntax
from rich.prompt import Prompt
from rich.markdown import Markdown

# Import the Agent class directly
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, current_dir)
from agent import Agent

class AgentInterface:
    def __init__(self):
        self.console = Console()
        self.agent = Agent()
        self.current_plan = None
        self.model_aliases = {
            "flash": "openrouter/google/gemini-2.0-flash-001",
            "r1": "deepseek/deepseek-reasoner",
            "claude": "openrouter/anthropic/claude-3.7-sonnet"
        }
        self.chat_history = []
        self.history_file = "chat_history.json"
        self.load_chat_history()
    
    def display_welcome(self):
        """Display welcome message and instructions"""
        self.console.print(Panel.fit(
            "[bold blue]Agent Interface[/bold blue]\n"
            "A simple interface for the agent planning system\n"
            "Type [bold]/help[/bold] for available commands\n"
            "Any text not starting with / will be sent directly to the model",
            title="Welcome",
            border_style="blue"
        ))
    
    def display_help(self):
        """Display available commands"""
        self.console.print("[bold]Available Commands:[/bold]")
        self.console.print("")
        self.console.print("[bold green]/init[/bold green]", "- Initialize the agent")
        self.console.print("[bold green]/plan [spec_file][/bold green]", "- Generate a plan from specification (default: spec.md)")
        self.console.print("[bold green]/display[/bold green]", "- Display the current plan")
        self.console.print("[bold green]/update <task_id> <status> [--notes=text] [--progress=0-100][/bold green]", "- Update task status")
        self.console.print("[bold green]/execute <task_id>[/bold green]", "- Execute a specific task (with confirmation)")
        self.console.print("[bold green]/execute-ready[/bold green]", "- Execute all ready tasks in dependency order")
        self.console.print("[bold green]/modify-plan[/bold green]", "- Let the agent suggest modifications to the plan")
        self.console.print("[bold green]/model <model_name>[/bold green]", "- Change the model (aliases: flash, r1, claude)")
        self.console.print("[bold green]/history [count][/bold green]", "- Display chat history (default: last 10 messages)")
        self.console.print("[bold green]/clear-history[/bold green]", "- Clear the chat history")
        self.console.print("[bold green]/help[/bold green]", "- Show this help")
        self.console.print("[bold green]/exit[/bold green]", "- Exit the interface")
        self.console.print("")
        self.console.print("[italic]Any text not starting with / will be sent directly to the model as a chat message[/italic]")
    
    def execute_action(self, action_element):
        """Execute a single action from the XML"""
        try:
            action_type = action_element.get("type", "unknown")
            path = action_element.get("path", "")
            command = action_element.get("command", "")
            
            # Determine syntax highlighting language based on file extension
            language = "python"  # default
            if path:
                ext = os.path.splitext(path)[1].lower()
                if ext in ['.js', '.jsx']:
                    language = "javascript"
                elif ext in ['.html', '.htm']:
                    language = "html"
                elif ext in ['.css']:
                    language = "css"
                elif ext in ['.json']:
                    language = "json"
                elif ext in ['.md']:
                    language = "markdown"
                elif ext in ['.sh']:
                    language = "bash"
                elif ext in ['.yml', '.yaml']:
                    language = "yaml"
            
            # Ask for confirmation before executing
            if action_type == "create_file":
                content = action_element.text.strip() if action_element.text else ""
                self.console.print(f"[bold cyan]Action:[/bold cyan] Create file '{path}'")
                self.console.print(Syntax(content, language, theme="monokai"))
                
            elif action_type == "modify_file":
                self.console.print(f"[bold cyan]Action:[/bold cyan] Modify file '{path}'")
                for change in action_element.findall("./change"):
                    original = change.find("original").text if change.find("original") is not None else ""
                    new = change.find("new").text if change.find("new") is not None else ""
                    self.console.print("[bold red]- Original:[/bold red]")
                    self.console.print(Syntax(original, language, theme="monokai"))
                    self.console.print("[bold green]+ New:[/bold green]")
                    self.console.print(Syntax(new, language, theme="monokai"))
                    
            elif action_type == "run_command":
                self.console.print(f"[bold cyan]Action:[/bold cyan] Run command '{command}'")
            
            # Ask for confirmation
            confirm = Prompt.ask(
                "\nExecute this action?", 
                choices=["y", "n"], 
                default="n"
            )
            
            if confirm.lower() != "y":
                self.console.print("[bold yellow]Action skipped[/bold yellow]")
                return False
            
            # Execute the action
            if action_type == "create_file":
                # Create the file with the content
                content = action_element.text.strip() if action_element.text else ""
                
                # Create directory if it doesn't exist
                directory = os.path.dirname(path)
                if directory and not os.path.exists(directory):
                    os.makedirs(directory)
                    self.console.print(f"[bold green]Created directory: {directory}[/bold green]")
                
                with open(path, 'w') as f:
                    f.write(content)
                self.console.print(f"[bold green]Created file: {path}[/bold green]")
                
                # Make executable if it's a script
                if path.endswith('.py') or not os.path.splitext(path)[1]:
                    os.chmod(path, 0o755)
                    self.console.print(f"[bold green]Made file executable: {path}[/bold green]")
                
                return True
                
            elif action_type == "modify_file":
                if not os.path.exists(path):
                    self.console.print(f"[bold red]Error: File {path} does not exist[/bold red]")
                    return False
                
                # Read the original file
                with open(path, 'r') as f:
                    file_content = f.read()
                
                # Apply each change
                changes_applied = False
                for change in action_element.findall("./change"):
                    original = change.find("original").text if change.find("original") is not None else ""
                    new = change.find("new").text if change.find("new") is not None else ""
                    
                    if original in file_content:
                        file_content = file_content.replace(original, new)
                        changes_applied = True
                    else:
                        self.console.print(f"[bold yellow]Warning: Could not find text to replace in {path}[/bold yellow]")
                
                # Write the modified content back
                if changes_applied:
                    with open(path, 'w') as f:
                        f.write(file_content)
                    self.console.print(f"[bold green]Modified file: {path}[/bold green]")
                    return True
                else:
                    self.console.print(f"[bold yellow]No changes applied to {path}[/bold yellow]")
                    return False
                
            elif action_type == "run_command":
                self.console.print(f"[bold blue]Running command: {command}[/bold blue]")
                
                # Run the command and capture output
                process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                
                # Stream output in real-time
                for line in process.stdout:
                    self.console.print(line.rstrip())
                
                # Wait for process to complete
                process.wait()
                
                if process.returncode == 0:
                    self.console.print(f"[bold green]Command completed successfully[/bold green]")
                    return True
                else:
                    stderr = process.stderr.read()
                    self.console.print(f"[bold red]Command failed with exit code {process.returncode}[/bold red]")
                    if stderr:
                        self.console.print(f"[bold red]Error: {stderr}[/bold red]")
                    return False
            
            else:
                self.console.print(f"[bold yellow]Unknown action type: {action_type}[/bold yellow]")
                return False
                
        except Exception as e:
            self.console.print(f"[bold red]Error executing action: {e}[/bold red]")
            return False
    
    def update_dependent_tasks(self, root, completed_task_id):
        """Update tasks that depend on the completed task"""
        # Find all tasks that depend on the completed task
        for task in root.findall(".//task"):
            depends_on = task.get("depends_on", "")
            if depends_on:
                dependencies = [dep.strip() for dep in depends_on.split(",")]
                if completed_task_id in dependencies:
                    # Check if all dependencies are completed
                    all_deps_completed = True
                    for dep_id in dependencies:
                        if dep_id == completed_task_id:
                            continue  # This one is completed
                        
                        dep_task = root.find(f".//task[@id='{dep_id}']")
                        if dep_task is None or dep_task.get("status") != "completed":
                            all_deps_completed = False
                            break
                    
                    # If all dependencies are completed, mark this task as ready
                    if all_deps_completed:
                        current_status = task.get("status", "pending")
                        if current_status == "pending":
                            task.set("status", "ready")
                            self.console.print(f"[bold blue]Task {task.get('id')} is now ready to be executed[/bold blue]")
    
    def display_plan_tree(self, xml_content: str):
        """Display the plan as a rich tree"""
        try:
            # Parse the XML
            root = ET.fromstring(xml_content)
            plan_element = root.find(".//plan")
            
            if plan_element is None:
                self.console.print("[bold red]Error:[/bold red] No plan found in XML")
                return
            
            # Create a rich tree
            tree = Tree("[bold blue]Plan[/bold blue]")
            
            # Process tasks recursively
            def add_tasks(parent_element, parent_tree):
                for task in parent_element.findall("./task"):
                    task_id = task.get("id", "unknown")
                    description = task.get("description", "No description")
                    status = task.get("status", "pending")
                    complexity = task.get("complexity", "unknown")
                    
                    # Choose color based on status
                    status_color = {
                        "pending": "yellow",
                        "in-progress": "blue",
                        "completed": "green",
                        "failed": "red"
                    }.get(status, "white")
                    
                    # Get dependencies and progress
                    depends_on = task.get("depends_on", "")
                    progress = task.get("progress", "0")
                    
                    # Create task node
                    task_text = f"[bold]{task_id}[/bold]: {description} "
                    task_text += f"[{status_color}]({status})[/{status_color}]"
                    
                    # Add progress bar if available
                    if progress and progress.isdigit():
                        progress_int = int(progress)
                        progress_bar = "█" * (progress_int // 10) + "░" * (10 - (progress_int // 10))
                        task_text += f" [{status_color}]{progress_bar} {progress}%[/{status_color}]"
                    
                    task_text += f" [dim]complexity: {complexity}[/dim]"
                    
                    # Add dependencies if present
                    if depends_on:
                        task_text += f" [dim italic]depends on: {depends_on}[/dim italic]"
                    
                    task_node = parent_tree.add(task_text)
                    
                    # Add notes if present
                    notes = task.get("notes")
                    if notes:
                        task_node.add(f"[italic dim]Notes: {notes}[/italic dim]")
                    
                    # Process subtasks
                    add_tasks(task, task_node)
            
            # Start with the root task
            root_task = plan_element.find("./task")
            if root_task is not None:
                add_tasks(plan_element, tree)
            
            # Display the tree
            self.console.print(tree)
            
        except ET.ParseError as e:
            self.console.print(f"[bold red]Error parsing XML:[/bold red] {e}")
        except Exception as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")
    
    def run_command(self, command: List[str], is_slash_command: bool = True):
        """Run a command and handle the result"""
        if not command:
            return
        
        cmd = command[0].lower()
        args = command[1:]
        
        # If not a slash command, treat as chat with the model
        if not is_slash_command:
            self.chat_with_model(" ".join([cmd] + args))
            return
        
        if cmd == "help":
            self.display_help()
        
        elif cmd == "exit":
            self.console.print("[bold blue]Exiting...[/bold blue]")
            sys.exit(0)
        
        elif cmd == "init":
            with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                self.agent.initialize()
            self.console.print("[bold green]Agent initialized successfully[/bold green]")
        
        elif cmd == "modify-plan":
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            self.console.print("[bold blue]Asking agent to suggest plan modifications...[/bold blue]")
            
            try:
                # Get the current plan status
                root = ET.fromstring(self.agent.plan_tree)
                
                # Count tasks by status
                status_counts = {"pending": 0, "ready": 0, "in-progress": 0, "completed": 0, "failed": 0}
                for task in root.findall(".//task"):
                    status = task.get("status", "pending")
                    if status in status_counts:
                        status_counts[status] += 1
                
                # Generate a prompt for the agent
                prompt = f"""
                Review the current plan and suggest modifications based on the current state.
                
                CURRENT PLAN STATUS:
                - Pending tasks: {status_counts["pending"]}
                - Ready tasks: {status_counts["ready"]}
                - In-progress tasks: {status_counts["in-progress"]}
                - Completed tasks: {status_counts["completed"]}
                - Failed tasks: {status_counts["failed"]}
                
                CURRENT PLAN:
                {self.agent.plan_tree}
                
                Based on the current state, suggest modifications to the plan. These could include:
                - Adding new tasks that were not initially considered
                - Modifying existing tasks based on what we've learned
                - Removing tasks that are no longer necessary
                - Adjusting dependencies between tasks
                
                Return your suggestions in this XML format:
                
                <plan_update>
                  <add_task parent_id="task1" id="task1.3" description="New subtask" status="pending" complexity="medium" depends_on="" progress="0" />
                  <modify_task id="task2" description="Updated description" />
                  <remove_task id="task3" />
                </plan_update>
                
                Only include changes that are necessary. If no changes are needed, return an empty plan_update element.
                """
                
                # Stream the reasoning process
                response = self.agent.stream_reasoning(prompt)
                
                # Extract plan_update XML from the response
                plan_update_xml = self.agent.extract_xml_from_response(response, "plan_update")
                
                if plan_update_xml:
                    # Parse the plan update
                    update_root = ET.fromstring(plan_update_xml)
                    
                    # Count the number of changes
                    add_tasks = update_root.findall("./add_task")
                    modify_tasks = update_root.findall("./modify_task")
                    remove_tasks = update_root.findall("./remove_task")
                    
                    total_changes = len(add_tasks) + len(modify_tasks) + len(remove_tasks)
                    
                    if total_changes == 0:
                        self.console.print("[bold green]No changes suggested by the agent[/bold green]")
                        return
                    
                    # Display the suggested changes
                    self.console.print(f"[bold blue]Agent suggests {total_changes} changes:[/bold blue]")
                    
                    for add_task in add_tasks:
                        parent_id = add_task.get("parent_id", "unknown")
                        task_id = add_task.get("id", "unknown")
                        description = add_task.get("description", "No description")
                        self.console.print(f"[bold green]+ Add task {task_id}[/bold green] to parent {parent_id}: {description}")
                    
                    for modify_task in modify_tasks:
                        task_id = modify_task.get("id", "unknown")
                        description = modify_task.get("description", "")
                        self.console.print(f"[bold yellow]~ Modify task {task_id}[/bold yellow]" + (f": {description}" if description else ""))
                    
                    for remove_task in remove_tasks:
                        task_id = remove_task.get("id", "unknown")
                        self.console.print(f"[bold red]- Remove task {task_id}[/bold red]")
                    
                    # Ask for confirmation
                    confirm = Prompt.ask(
                        "\nApply these changes?", 
                        choices=["y", "n"], 
                        default="n"
                    )
                    
                    if confirm.lower() == "y":
                        # Apply the changes
                        self.agent.apply_plan_updates(plan_update_xml)
                        
                        # Save the updated plan
                        with open("agent_plan.xml", 'w') as f:
                            f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                        
                        self.console.print("[bold green]Plan updated successfully[/bold green]")
                        
                        # Display the updated plan
                        self.display_plan_tree(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                    else:
                        self.console.print("[bold yellow]Changes discarded[/bold yellow]")
                else:
                    self.console.print("[bold yellow]No plan updates found in the response[/bold yellow]")
            
            except Exception as e:
                self.console.print(f"[bold red]Error modifying plan: {e}[/bold red]")
        
        elif cmd == "history":
            # Display chat history
            count = 10  # Default to last 10 messages
            if args and args[0].isdigit():
                count = int(args[0])
            
            if not self.chat_history:
                self.console.print("[bold yellow]No chat history available[/bold yellow]")
                return
            
            # Get the specified number of messages from the end of history
            messages_to_show = self.chat_history[-count:] if len(self.chat_history) > count else self.chat_history
            
            self.console.print(f"[bold blue]Chat History (last {len(messages_to_show)} messages):[/bold blue]")
            for i, msg in enumerate(messages_to_show):
                role = msg["role"]
                content = msg["content"]
                timestamp = msg.get("timestamp", "")
                
                # Format timestamp if available
                time_str = ""
                if timestamp:
                    try:
                        dt = datetime.datetime.fromisoformat(timestamp)
                        time_str = f"[dim]{dt.strftime('%Y-%m-%d %H:%M:%S')}[/dim]"
                    except:
                        time_str = f"[dim]{timestamp}[/dim]"
                
                # Format based on role
                if role == "user":
                    self.console.print(f"\n{time_str}")
                    self.console.print(f"[bold green]User:[/bold green] {content}")
                else:
                    self.console.print(f"\n{time_str}")
                    
                    # For assistant messages, try to extract and format the message part
                    message_xml = self.agent.extract_xml_from_response(content, "message")
                    if message_xml:
                        try:
                            root = ET.fromstring(message_xml)
                            message_text = root.text if root.text else ""
                            self.console.print(f"[bold blue]Assistant:[/bold blue]")
                            self.console.print(Markdown(message_text))
                        except ET.ParseError:
                            self.console.print(f"[bold blue]Assistant:[/bold blue] {content[:100]}...")
                    else:
                        self.console.print(f"[bold blue]Assistant:[/bold blue] {content[:100]}...")
        
        elif cmd == "clear-history":
            confirm = Prompt.ask(
                "Are you sure you want to clear the chat history?", 
                choices=["y", "n"], 
                default="n"
            )
            
            if confirm.lower() == "y":
                self.chat_history = []
                self.save_chat_history()
                self.console.print("[bold green]Chat history cleared[/bold green]")
            else:
                self.console.print("[bold yellow]Operation cancelled[/bold yellow]")
                
        elif cmd == "model":
            if not args:
                self.console.print(f"[bold blue]Current model:[/bold blue] {self.agent.model_name}")
                return
                
            model_name = args[0]
            
            # Check for model aliases
            if model_name in self.model_aliases:
                model_name = self.model_aliases[model_name]
                
            self.agent.model_name = model_name
            self.console.print(f"[bold green]Model changed to:[/bold green] {self.agent.model_name}")
        
        elif cmd == "plan":
            # Use spec.md by default if no file specified
            spec_file = args[0] if args else "spec.md"
            self.console.print(f"[bold blue]Using specification file:[/bold blue] {spec_file}")
            try:
                with open(spec_file, 'r') as f:
                    spec = f.read()
                
                self.console.print(f"[bold blue]Using model:[/bold blue] {self.agent.model_name}")
                
                # Initialize if not already done
                if not self.agent.repository_info:
                    with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                        self.agent.initialize()
                
                # Generate plan - don't use status context manager to allow streaming
                self.console.print("[bold blue]Generating plan...[/bold blue]")
                try:
                    # Set a callback to handle streaming in the interface
                    def stream_callback(content, is_reasoning=False):
                        if is_reasoning:
                            # Use yellow color for reasoning tokens
                            self.console.print(f"[yellow]{content}[/yellow]", end="")
                        else:
                            # Use rich for normal content
                            self.console.print(content, end="", highlight=False)
                            
                    # Pass the callback to the agent
                    self.agent.stream_callback = stream_callback
                    result = self.agent.generate_plan(spec)
                            
                    # Save the plan to a file
                    with open("agent_plan.xml", 'w') as f:
                        f.write(result)
                            
                    # Extract plan XML for display
                    plan_xml = self.agent.extract_xml_from_response(result, "plan")
                    if plan_xml:
                        self.current_plan = result
                        self.console.print("\n\n[bold blue]Generated Plan:[/bold blue]")
                        self.display_plan_tree(result)
                    else:
                        self.console.print("[bold red]Error:[/bold red] No plan found in response")
                                
                    self.console.print("[bold green]Plan saved to agent_plan.xml[/bold green]")
                            
                except KeyboardInterrupt:
                    self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
                
            except FileNotFoundError:
                self.console.print(f"[bold red]Error:[/bold red] Specification file '{spec_file}' not found")
        
        elif cmd == "display":
            # Load the plan from file if not already loaded
            if not self.current_plan:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                        self.current_plan = xml_content
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            self.display_plan_tree(self.current_plan)
        
        elif cmd == "update":
            if len(args) < 2:
                self.console.print("[bold red]Error:[/bold red] Missing task_id or status")
                return
            
            task_id = args[0]
            status = args[1]
            
            # Check for progress and notes flags
            progress = None
            notes = None
            
            for i, arg in enumerate(args[2:], 2):
                if arg.startswith("--progress="):
                    progress = arg.split("=")[1]
                elif arg.startswith("--notes="):
                    notes = arg.split("=")[1]
                elif i == 2 and not arg.startswith("--"):
                    # For backward compatibility, treat the third argument as notes
                    notes = arg
            
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            with self.console.status(f"[bold blue]Updating task {task_id}...[/bold blue]"):
                result = self.agent.update_plan(task_id, status, notes, progress)
            
            # Save the updated plan
            with open("agent_plan.xml", 'w') as f:
                f.write(result)
            
            self.current_plan = result
            self.console.print(f"[bold green]Task {task_id} updated to {status}[/bold green]")
            self.display_plan_tree(result)
        
        elif cmd == "execute-ready":
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            # Find all ready tasks
            try:
                root = ET.fromstring(self.agent.plan_tree)
                ready_tasks = []
                
                # First pass: find all tasks with status "ready" or "pending" with no dependencies
                for task in root.findall(".//task"):
                    task_id = task.get("id")
                    status = task.get("status", "pending")
                    depends_on = task.get("depends_on", "")
                    
                    if status == "ready" or (status == "pending" and not depends_on):
                        # Check if dependencies are met
                        deps_met, _ = self.agent.check_dependencies(task_id)
                        if deps_met:
                            ready_tasks.append((task_id, task.get("description", "")))
                
                if not ready_tasks:
                    self.console.print("[bold yellow]No ready tasks found[/bold yellow]")
                    return
                
                # Display ready tasks
                self.console.print("[bold blue]Ready tasks:[/bold blue]")
                for i, (task_id, desc) in enumerate(ready_tasks):
                    self.console.print(f"[bold]{i+1}.[/bold] {task_id}: {desc}")
                
                # Ask which tasks to execute
                confirm = Prompt.ask(
                    "\nExecute all ready tasks?", 
                    choices=["y", "n", "select"], 
                    default="n"
                )
                
                if confirm.lower() == "n":
                    self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                    return
                
                tasks_to_execute = []
                
                if confirm.lower() == "select":
                    # Let user select specific tasks
                    selection = Prompt.ask(
                        "Enter task numbers to execute (comma-separated)", 
                        default="1"
                    )
                    try:
                        selected_indices = [int(idx.strip()) - 1 for idx in selection.split(",")]
                        for idx in selected_indices:
                            if 0 <= idx < len(ready_tasks):
                                tasks_to_execute.append(ready_tasks[idx][0])  # Add task_id
                    except ValueError:
                        self.console.print("[bold red]Invalid selection[/bold red]")
                        return
                else:
                    # Execute all ready tasks
                    tasks_to_execute = [task[0] for task in ready_tasks]  # Get all task_ids
                
                # Execute each selected task
                for task_id in tasks_to_execute:
                    self.console.print(f"\n[bold blue]Executing task {task_id}...[/bold blue]")
                    
                    try:
                        result = self.agent.execute_task(task_id)
                        
                        # Check for errors
                        error_element = ET.fromstring(result).find(".//error")
                        if error_element is not None and error_element.text:
                            self.console.print(f"[bold red]Error:[/bold red] {error_element.text}")
                            continue
                        
                        # Save the actions to a file
                        with open(f"agent_actions_{task_id}.xml", 'w') as f:
                            f.write(result)
                        
                        # Save the updated plan
                        with open("agent_plan.xml", 'w') as f:
                            f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                        
                        # Display the actions
                        actions_xml = self.agent.extract_xml_from_response(result, "actions")
                        if actions_xml:
                            # Parse the actions to show them individually for confirmation
                            try:
                                actions_root = ET.fromstring(actions_xml)
                                actions_count = len(actions_root.findall("./action"))
                                
                                # Ask if user wants to execute all actions or confirm each one
                                if actions_count > 1:
                                    execute_mode = Prompt.ask(
                                        "\nHow do you want to execute actions?", 
                                        choices=["all", "one-by-one", "cancel"], 
                                        default="one-by-one"
                                    )
                                    
                                    if execute_mode == "cancel":
                                        self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                                        continue
                                else:
                                    execute_mode = "one-by-one"
                                
                                successful_actions = 0
                                
                                if execute_mode == "all":
                                    # Execute all actions with a single confirmation
                                    confirm = Prompt.ask(
                                        f"\nExecute all {actions_count} actions?", 
                                        choices=["y", "n"], 
                                        default="n"
                                    )
                                    
                                    if confirm.lower() == "y":
                                        with self.console.status(f"[bold blue]Executing {actions_count} actions...[/bold blue]"):
                                            for i, action in enumerate(actions_root.findall("./action")):
                                                self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                                                if self.execute_action(action):
                                                    successful_actions += 1
                                    else:
                                        self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                                        continue
                                else:
                                    # Execute actions one by one with confirmation for each
                                    for i, action in enumerate(actions_root.findall("./action")):
                                        self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                                        
                                        # Execute the action with confirmation
                                        if self.execute_action(action):
                                            successful_actions += 1
                                
                                # Update task progress based on completed actions
                                if actions_count > 0:
                                    completion_percentage = int((successful_actions / actions_count) * 30) + 70
                                    if successful_actions == actions_count:
                                        # All actions completed successfully
                                        self.console.print("[bold green]All actions completed successfully[/bold green]")
                                        
                                        # Parse the plan tree
                                        root = ET.fromstring(self.agent.plan_tree)
                                        task_element = root.find(f".//task[@id='{task_id}']")
                                        if task_element is not None:
                                            task_element.set("status", "completed")
                                            task_element.set("progress", "100")
                                            
                                            # Update dependent tasks to be ready
                                            self.update_dependent_tasks(root, task_id)
                                            
                                            self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                            
                                            # Save the updated plan
                                            with open("agent_plan.xml", 'w') as f:
                                                f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                            
                                            self.console.print(f"[bold green]Task {task_id} marked as completed[/bold green]")
                                    else:
                                        # Some actions failed
                                        self.console.print(f"[bold yellow]{successful_actions}/{actions_count} actions completed[/bold yellow]")
                                        
                                        # Parse the plan tree
                                        root = ET.fromstring(self.agent.plan_tree)
                                        task_element = root.find(f".//task[@id='{task_id}']")
                                        if task_element is not None:
                                            task_element.set("progress", str(completion_percentage))
                                            self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                            
                                            # Save the updated plan
                                            with open("agent_plan.xml", 'w') as f:
                                                f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                            
                                            self.console.print(f"[bold yellow]Task {task_id} progress updated to {completion_percentage}%[/bold yellow]")
                            
                            except ET.ParseError:
                                self.console.print("[bold red]Error parsing actions XML[/bold red]")
                        
                        self.console.print(f"[bold green]Actions saved to agent_actions_{task_id}.xml[/bold green]")
                        
                    except KeyboardInterrupt:
                        self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
                        break
                    except Exception as e:
                        self.console.print(f"[bold red]Error executing task {task_id}: {e}[/bold red]")
                
                # Display the updated plan
                self.display_plan_tree(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                
            except ET.ParseError:
                self.console.print("[bold red]Error parsing plan XML[/bold red]")
            except Exception as e:
                self.console.print(f"[bold red]Error: {e}[/bold red]")
        
        elif cmd == "execute":
            if not args:
                self.console.print("[bold red]Error:[/bold red] Missing task_id")
                return
            
            task_id = args[0]
            
            # Load the plan from file if not already loaded
            if not self.agent.plan_tree:
                try:
                    with open("agent_plan.xml", 'r') as f:
                        xml_content = f.read()
                        self.agent.plan_tree = self.agent.extract_xml_from_response(xml_content, "plan")
                except FileNotFoundError:
                    self.console.print("[bold red]Error:[/bold red] No plan file found. Generate a plan first.")
                    return
            
            # Check dependencies first
            deps_met, missing_deps = self.agent.check_dependencies(task_id)
            if not deps_met:
                self.console.print("[bold red]Error:[/bold red] Dependencies not met")
                for dep in missing_deps:
                    self.console.print(f"[bold yellow]- {dep}[/bold yellow]")
                
                confirm = Prompt.ask(
                    "\nContinue anyway?", 
                    choices=["y", "n"], 
                    default="n"
                )
                if confirm.lower() != "y":
                    self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                    return
            
            self.console.print(f"[bold blue]Executing task {task_id}...[/bold blue]")
            
            try:
                result = self.agent.execute_task(task_id)
                
                # Check for errors
                error_element = ET.fromstring(result).find(".//error")
                if error_element is not None and error_element.text:
                    self.console.print(f"[bold red]Error:[/bold red] {error_element.text}")
                    return
                
                # Save the actions to a file
                with open(f"agent_actions_{task_id}.xml", 'w') as f:
                    f.write(result)
                
                # Save the updated plan
                with open("agent_plan.xml", 'w') as f:
                    f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                
                # Display the actions
                actions_xml = self.agent.extract_xml_from_response(result, "actions")
                if actions_xml:
                    # Clean up XML for display
                    try:
                        root = ET.fromstring(actions_xml)
                        clean_xml = ET.tostring(root, encoding='unicode')
                        syntax = Syntax(clean_xml, "xml", theme="monokai", line_numbers=True)
                        self.console.print(Panel(syntax, title=f"Actions for Task {task_id}", border_style="green"))
                    except ET.ParseError:
                        # Fallback if XML parsing fails
                        syntax = Syntax(actions_xml, "xml", theme="monokai", line_numbers=True)
                        self.console.print(Panel(syntax, title=f"Actions for Task {task_id}", border_style="green"))
                    
                    # Parse the actions to show them individually for confirmation
                    try:
                        actions_root = ET.fromstring(actions_xml)
                        actions_count = len(actions_root.findall("./action"))
                            
                        # Ask if user wants to execute all actions or confirm each one
                        if actions_count > 1:
                            execute_mode = Prompt.ask(
                                "\nHow do you want to execute actions?", 
                                choices=["all", "one-by-one", "cancel"], 
                                default="one-by-one"
                            )
                                
                            if execute_mode == "cancel":
                                self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                                return
                        else:
                            execute_mode = "one-by-one"
                            
                        successful_actions = 0
                            
                        if execute_mode == "all":
                            # Execute all actions with a single confirmation
                            confirm = Prompt.ask(
                                f"\nExecute all {actions_count} actions?", 
                                choices=["y", "n"], 
                                default="n"
                            )
                                
                            if confirm.lower() == "y":
                                with self.console.status(f"[bold blue]Executing {actions_count} actions...[/bold blue]"):
                                    for i, action in enumerate(actions_root.findall("./action")):
                                        self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                                        if self.execute_action(action):
                                            successful_actions += 1
                            else:
                                self.console.print("[bold yellow]Execution cancelled[/bold yellow]")
                                return
                        else:
                            # Execute actions one by one with confirmation for each
                            for i, action in enumerate(actions_root.findall("./action")):
                                self.console.print(f"\n[bold cyan]Action {i+1}/{actions_count}:[/bold cyan]")
                                    
                                # Execute the action with confirmation
                                if self.execute_action(action):
                                    successful_actions += 1
                            
                        # Update task progress based on completed actions
                        if actions_count > 0:
                            completion_percentage = int((successful_actions / actions_count) * 30) + 70
                            if successful_actions == actions_count:
                                # All actions completed successfully
                                self.console.print("[bold green]All actions completed successfully[/bold green]")
                                    
                                # Parse the plan tree
                                root = ET.fromstring(self.agent.plan_tree)
                                task_element = root.find(f".//task[@id='{task_id}']")
                                if task_element is not None:
                                    task_element.set("status", "completed")
                                    task_element.set("progress", "100")
                                        
                                    # Update dependent tasks to be ready
                                    self.update_dependent_tasks(root, task_id)
                                        
                                    self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                        
                                    # Save the updated plan
                                    with open("agent_plan.xml", 'w') as f:
                                        f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                        
                                    self.console.print(f"[bold green]Task {task_id} marked as completed[/bold green]")
                            else:
                                # Some actions failed
                                self.console.print(f"[bold yellow]{successful_actions}/{actions_count} actions completed[/bold yellow]")
                                    
                                # Parse the plan tree
                                root = ET.fromstring(self.agent.plan_tree)
                                task_element = root.find(f".//task[@id='{task_id}']")
                                if task_element is not None:
                                    task_element.set("progress", str(completion_percentage))
                                    self.agent.plan_tree = ET.tostring(root, encoding='unicode')
                                        
                                    # Save the updated plan
                                    with open("agent_plan.xml", 'w') as f:
                                        f.write(self.agent.format_xml_response({"plan": self.agent.plan_tree}))
                                        
                                    self.console.print(f"[bold yellow]Task {task_id} progress updated to {completion_percentage}%[/bold yellow]")
                    
                    except ET.ParseError:
                        self.console.print("[bold red]Error parsing actions XML[/bold red]")
                
                self.console.print(f"[bold green]Actions saved to agent_actions_{task_id}.xml[/bold green]")
                
            except KeyboardInterrupt:
                self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
        
        else:
            self.console.print(f"[bold red]Unknown command:[/bold red] {cmd}")
            self.console.print("Type [bold]help[/bold] for available commands")
    
    def execute_shell_command(self, command: str, auto_run: bool = False) -> bool:
        """Execute a shell command with optional auto-run"""
        self.console.print(f"[bold cyan]Shell Command:[/bold cyan] {command}")
        
        if not auto_run:
            confirm = Prompt.ask(
                "\nExecute this shell command?", 
                choices=["y", "n"], 
                default="n"
            )
            
            if confirm.lower() != "y":
                self.console.print("[bold yellow]Command execution skipped[/bold yellow]")
                return False
        
        self.console.print(f"[bold blue]Running command: {command}[/bold blue]")
        
        # Run the command and capture output
        process = subprocess.Popen(
            command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        # Stream output in real-time
        for line in process.stdout:
            self.console.print(line.rstrip())
        
        # Wait for process to complete
        process.wait()
        
        if process.returncode == 0:
            self.console.print(f"[bold green]Command completed successfully[/bold green]")
            return True
        else:
            stderr = process.stderr.read()
            self.console.print(f"[bold red]Command failed with exit code {process.returncode}[/bold red]")
            if stderr:
                self.console.print(f"[bold red]Error: {stderr}[/bold red]")
            return False
    
    def load_chat_history(self):
        """Load chat history from file if it exists"""
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    self.chat_history = json.load(f)
                    self.console.print(f"[dim]Loaded {len(self.chat_history)} previous messages[/dim]")
        except Exception as e:
            self.console.print(f"[dim]Could not load chat history: {e}[/dim]")
            self.chat_history = []
    
    def save_chat_history(self):
        """Save chat history to file"""
        try:
            with open(self.history_file, 'w') as f:
                json.dump(self.chat_history, f, indent=2)
        except Exception as e:
            self.console.print(f"[dim]Could not save chat history: {e}[/dim]")
    
    def chat_with_model(self, message: str):
        """Send a message directly to the model and handle the response"""
        # Initialize agent if not already done
        if not self.agent.repository_info:
            with self.console.status("[bold blue]Initializing agent...[/bold blue]"):
                self.agent.initialize()
        
        # Add user message to history
        timestamp = datetime.datetime.now().isoformat()
        self.chat_history.append({
            "role": "user",
            "content": message,
            "timestamp": timestamp
        })
        
        self.console.print(f"[bold blue]Sending message to model ({self.agent.model_name})...[/bold blue]")
        
        # Get current date, time and timezone
        now = datetime.datetime.now()
        timezone = datetime.datetime.now().astimezone().tzinfo
        
        # Construct a prompt that instructs the model to respond in XML format
        prompt = f"""
        You are an AI assistant that can respond to user queries and also perform actions.
        
        CURRENT DATE: {now.strftime('%Y-%m-%d')}
        CURRENT TIME: {now.strftime('%H:%M:%S')}
        TIMEZONE: {timezone}
        
        CONVERSATION HISTORY:
        {self._format_history_for_prompt()}
        
        USER MESSAGE: {message}
        
        You can respond in the following ways:
        
        1. Simple message:
        <message>Your response text here</message>
        
        2. Actions to execute:
        <actions>
          <action type="create_file" path="example.py">
            # Python code here
          </action>
          <action type="modify_file" path="existing.py">
            <change>
              <original>def old_function():</original>
              <new>def new_function():</new>
            </change>
          </action>
        </actions>
        
        3. Shell commands:
        <shell_commands>
          <command safe_to_autorun="true">echo "Hello World"</command>
          <command safe_to_autorun="false">rm -rf some_directory</command>
        </shell_commands>
        
        You can include multiple response types in a single reply.
        For shell commands, set safe_to_autorun="true" only for commands that are completely safe and have no destructive potential.
        """
        
        try:
            # Set a callback to handle streaming in the interface
            def stream_callback(content, is_reasoning=False):
                if is_reasoning:
                    # Use yellow color for reasoning tokens
                    self.console.print(f"[yellow]{content}[/yellow]", end="")
                else:
                    # Use rich for normal content
                    self.console.print(content, end="", highlight=False)
                    
            # Pass the callback to the agent
            self.agent.stream_callback = stream_callback
            response = self.agent.stream_reasoning(prompt)
            
            # Process the response
            self.process_chat_response(response)
                
        except KeyboardInterrupt:
            self.console.print("\n[bold yellow]Operation cancelled by user[/bold yellow]")
    
    def _format_history_for_prompt(self):
        """Format chat history for inclusion in the prompt"""
        # Limit history to last 10 messages to avoid context overflow
        recent_history = self.chat_history[-10:] if len(self.chat_history) > 10 else self.chat_history
        
        formatted_history = []
        for msg in recent_history[:-1]:  # Exclude the current message which is added separately
            role = msg["role"].upper()
            content = msg["content"]
            formatted_history.append(f"{role}: {content}")
        
        return "\n".join(formatted_history)
    
    def process_chat_response(self, response: str):
        """Process the XML response from the model chat"""
        # Extract different parts of the response
        message_xml = self.agent.extract_xml_from_response(response, "message")
        actions_xml = self.agent.extract_xml_from_response(response, "actions")
        shell_commands_xml = self.agent.extract_xml_from_response(response, "shell_commands")
        
        # Add response to history
        timestamp = datetime.datetime.now().isoformat()
        self.chat_history.append({
            "role": "assistant",
            "content": response,
            "timestamp": timestamp
        })
        
        # Save updated history
        self.save_chat_history()
        
        # Process message if present
        if message_xml:
            try:
                # Parse the XML to get just the text content
                root = ET.fromstring(message_xml)
                message_text = root.text if root.text else ""
                
                # Display the message as markdown
                self.console.print("")
                self.console.print(Markdown(message_text))
                self.console.print("")
            except ET.ParseError:
                # Fallback if parsing fails
                self.console.print(f"\n{message_xml}\n")
        
        # Process actions if present
        if actions_xml:
            try:
                actions_root = ET.fromstring(actions_xml)
                actions = actions_root.findall("./action")
                
                if actions:
                    self.console.print("[bold blue]The model suggests the following actions:[/bold blue]")
                    
                    for action in actions:
                        self.execute_action(action)
                        
            except ET.ParseError as e:
                self.console.print(f"[bold red]Error parsing actions XML: {e}[/bold red]")
        
        # Process shell commands if present
        if shell_commands_xml:
            try:
                commands_root = ET.fromstring(shell_commands_xml)
                commands = commands_root.findall("./command")
                
                if commands:
                    self.console.print("[bold blue]The model suggests the following shell commands:[/bold blue]")
                    
                    for cmd_elem in commands:
                        command = cmd_elem.text.strip() if cmd_elem.text else ""
                        auto_run = cmd_elem.get("safe_to_autorun", "false").lower() == "true"
                        
                        if auto_run:
                            self.console.print(f"[bold green]Auto-running safe command:[/bold green] {command}")
                            self.execute_shell_command(command, auto_run=True)
                        else:
                            self.execute_shell_command(command, auto_run=False)
                        
            except ET.ParseError as e:
                self.console.print(f"[bold red]Error parsing shell commands XML: {e}[/bold red]")
    
    def run_interactive(self):
        """Run the interface in interactive mode"""
        self.display_welcome()
        
        while True:
            try:
                user_input = Prompt.ask("\n[bold blue]>[/bold blue]")
                if user_input.lower() in ["exit", "quit", "q", "/exit", "/quit", "/q"]:
                    self.console.print("[bold blue]Exiting...[/bold blue]")
                    sys.exit(0)
                
                # Check if this is a slash command
                if user_input.startswith('/'):
                    # Remove the slash and split into command parts
                    command = user_input[1:].strip().split()
                    self.run_command(command)
                else:
                    # Treat as direct chat with the model
                    self.chat_with_model(user_input)
                    
            except KeyboardInterrupt:
                self.console.print("\n[bold yellow]Exiting...[/bold yellow]")
                sys.exit(0)
            except EOFError:  # Handle Ctrl+D
                self.console.print("\n[bold yellow]Exiting...[/bold yellow]")
                sys.exit(0)
            except Exception as e:
                self.console.print(f"[bold red]Error:[/bold red] {e}")

def main():
    """Main function to run the agent interface"""
    interface = AgentInterface()
    interface.run_interactive()

if __name__ == "__main__":
    main()
